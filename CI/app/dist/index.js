require("./sourcemap-register.js");
/******/ (() => {
  // webpackBootstrap
  /******/ "use strict";
  /******/ var __webpack_modules__ = {
    /***/ 236: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__,
    ) {
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected);
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next(),
            );
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getExecOutput = exports.exec = void 0;
      const string_decoder_1 = __nccwpck_require__(193);
      const tr = __importStar(__nccwpck_require__(665));
      /**
       * Exec a command.
       * Output will be streamed to the live console.
       * Returns promise with return code
       *
       * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
       * @param     args               optional arguments for tool. Escaping is handled by the lib.
       * @param     options            optional exec options.  See ExecOptions
       * @returns   Promise<number>    exit code
       */
      function exec(commandLine, args, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const commandArgs = tr.argStringToArray(commandLine);
          if (commandArgs.length === 0) {
            throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
          }
          // Path to tool to execute should be first arg
          const toolPath = commandArgs[0];
          args = commandArgs.slice(1).concat(args || []);
          const runner = new tr.ToolRunner(toolPath, args, options);
          return runner.exec();
        });
      }
      exports.exec = exec;
      /**
       * Exec a command and get the output.
       * Output will be streamed to the live console.
       * Returns promise with the exit code and collected stdout and stderr
       *
       * @param     commandLine           command to execute (can include additional args). Must be correctly escaped.
       * @param     args                  optional arguments for tool. Escaping is handled by the lib.
       * @param     options               optional exec options.  See ExecOptions
       * @returns   Promise<ExecOutput>   exit code, stdout, and stderr
       */
      function getExecOutput(commandLine, args, options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          let stdout = "";
          let stderr = "";
          //Using string decoder covers the case where a mult-byte character is split
          const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
          const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
          const originalStdoutListener =
            (_a =
              options === null || options === void 0
                ? void 0
                : options.listeners) === null || _a === void 0
              ? void 0
              : _a.stdout;
          const originalStdErrListener =
            (_b =
              options === null || options === void 0
                ? void 0
                : options.listeners) === null || _b === void 0
              ? void 0
              : _b.stderr;
          const stdErrListener = (data) => {
            stderr += stderrDecoder.write(data);
            if (originalStdErrListener) {
              originalStdErrListener(data);
            }
          };
          const stdOutListener = (data) => {
            stdout += stdoutDecoder.write(data);
            if (originalStdoutListener) {
              originalStdoutListener(data);
            }
          };
          const listeners = Object.assign(
            Object.assign(
              {},
              options === null || options === void 0
                ? void 0
                : options.listeners,
            ),
            { stdout: stdOutListener, stderr: stdErrListener },
          );
          const exitCode = yield exec(
            commandLine,
            args,
            Object.assign(Object.assign({}, options), { listeners }),
          );
          //flush any remaining characters
          stdout += stdoutDecoder.end();
          stderr += stderrDecoder.end();
          return {
            exitCode,
            stdout,
            stderr,
          };
        });
      }
      exports.getExecOutput = getExecOutput;
      //# sourceMappingURL=exec.js.map

      /***/
    },

    /***/ 665: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__,
    ) {
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected);
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next(),
            );
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.argStringToArray = exports.ToolRunner = void 0;
      const os = __importStar(__nccwpck_require__(857));
      const events = __importStar(__nccwpck_require__(434));
      const child = __importStar(__nccwpck_require__(317));
      const path = __importStar(__nccwpck_require__(928));
      const io = __importStar(__nccwpck_require__(994));
      const ioUtil = __importStar(__nccwpck_require__(207));
      const timers_1 = __nccwpck_require__(557);
      /* eslint-disable @typescript-eslint/unbound-method */
      const IS_WINDOWS = process.platform === "win32";
      /*
       * Class for running command line tools. Handles quoting and arg parsing in a platform agnostic way.
       */
      class ToolRunner extends events.EventEmitter {
        constructor(toolPath, args, options) {
          super();
          if (!toolPath) {
            throw new Error("Parameter 'toolPath' cannot be null or empty.");
          }
          this.toolPath = toolPath;
          this.args = args || [];
          this.options = options || {};
        }
        _debug(message) {
          if (this.options.listeners && this.options.listeners.debug) {
            this.options.listeners.debug(message);
          }
        }
        _getCommandString(options, noPrefix) {
          const toolPath = this._getSpawnFileName();
          const args = this._getSpawnArgs(options);
          let cmd = noPrefix ? "" : "[command]"; // omit prefix when piped to a second tool
          if (IS_WINDOWS) {
            // Windows + cmd file
            if (this._isCmdFile()) {
              cmd += toolPath;
              for (const a of args) {
                cmd += ` ${a}`;
              }
            }
            // Windows + verbatim
            else if (options.windowsVerbatimArguments) {
              cmd += `"${toolPath}"`;
              for (const a of args) {
                cmd += ` ${a}`;
              }
            }
            // Windows (regular)
            else {
              cmd += this._windowsQuoteCmdArg(toolPath);
              for (const a of args) {
                cmd += ` ${this._windowsQuoteCmdArg(a)}`;
              }
            }
          } else {
            // OSX/Linux - this can likely be improved with some form of quoting.
            // creating processes on Unix is fundamentally different than Windows.
            // on Unix, execvp() takes an arg array.
            cmd += toolPath;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          }
          return cmd;
        }
        _processLineBuffer(data, strBuffer, onLine) {
          try {
            let s = strBuffer + data.toString();
            let n = s.indexOf(os.EOL);
            while (n > -1) {
              const line = s.substring(0, n);
              onLine(line);
              // the rest of the string ...
              s = s.substring(n + os.EOL.length);
              n = s.indexOf(os.EOL);
            }
            return s;
          } catch (err) {
            // streaming lines to console is best effort.  Don't fail a build.
            this._debug(`error processing line. Failed with error ${err}`);
            return "";
          }
        }
        _getSpawnFileName() {
          if (IS_WINDOWS) {
            if (this._isCmdFile()) {
              return process.env["COMSPEC"] || "cmd.exe";
            }
          }
          return this.toolPath;
        }
        _getSpawnArgs(options) {
          if (IS_WINDOWS) {
            if (this._isCmdFile()) {
              let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
              for (const a of this.args) {
                argline += " ";
                argline += options.windowsVerbatimArguments
                  ? a
                  : this._windowsQuoteCmdArg(a);
              }
              argline += '"';
              return [argline];
            }
          }
          return this.args;
        }
        _endsWith(str, end) {
          return str.endsWith(end);
        }
        _isCmdFile() {
          const upperToolPath = this.toolPath.toUpperCase();
          return (
            this._endsWith(upperToolPath, ".CMD") ||
            this._endsWith(upperToolPath, ".BAT")
          );
        }
        _windowsQuoteCmdArg(arg) {
          // for .exe, apply the normal quoting rules that libuv applies
          if (!this._isCmdFile()) {
            return this._uvQuoteCmdArg(arg);
          }
          // otherwise apply quoting rules specific to the cmd.exe command line parser.
          // the libuv rules are generic and are not designed specifically for cmd.exe
          // command line parser.
          //
          // for a detailed description of the cmd.exe command line parser, refer to
          // http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912
          // need quotes for empty arg
          if (!arg) {
            return '""';
          }
          // determine whether the arg needs to be quoted
          const cmdSpecialChars = [
            " ",
            "\t",
            "&",
            "(",
            ")",
            "[",
            "]",
            "{",
            "}",
            "^",
            "=",
            ";",
            "!",
            "'",
            "+",
            ",",
            "`",
            "~",
            "|",
            "<",
            ">",
            '"',
          ];
          let needsQuotes = false;
          for (const char of arg) {
            if (cmdSpecialChars.some((x) => x === char)) {
              needsQuotes = true;
              break;
            }
          }
          // short-circuit if quotes not needed
          if (!needsQuotes) {
            return arg;
          }
          // the following quoting rules are very similar to the rules that by libuv applies.
          //
          // 1) wrap the string in quotes
          //
          // 2) double-up quotes - i.e. " => ""
          //
          //    this is different from the libuv quoting rules. libuv replaces " with \", which unfortunately
          //    doesn't work well with a cmd.exe command line.
          //
          //    note, replacing " with "" also works well if the arg is passed to a downstream .NET console app.
          //    for example, the command line:
          //          foo.exe "myarg:""my val"""
          //    is parsed by a .NET console app into an arg array:
          //          [ "myarg:\"my val\"" ]
          //    which is the same end result when applying libuv quoting rules. although the actual
          //    command line from libuv quoting rules would look like:
          //          foo.exe "myarg:\"my val\""
          //
          // 3) double-up slashes that precede a quote,
          //    e.g.  hello \world    => "hello \world"
          //          hello\"world    => "hello\\""world"
          //          hello\\"world   => "hello\\\\""world"
          //          hello world\    => "hello world\\"
          //
          //    technically this is not required for a cmd.exe command line, or the batch argument parser.
          //    the reasons for including this as a .cmd quoting rule are:
          //
          //    a) this is optimized for the scenario where the argument is passed from the .cmd file to an
          //       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.
          //
          //    b) it's what we've been doing previously (by deferring to node default behavior) and we
          //       haven't heard any complaints about that aspect.
          //
          // note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be
          // escaped when used on the command line directly - even though within a .cmd file % can be escaped
          // by using %%.
          //
          // the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts
          // the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.
          //
          // one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would
          // often work, since it is unlikely that var^ would exist, and the ^ character is removed when the
          // variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args
          // to an external program.
          //
          // an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.
          // % can be escaped within a .cmd file.
          let reverse = '"';
          let quoteHit = true;
          for (let i = arg.length; i > 0; i--) {
            // walk the string in reverse
            reverse += arg[i - 1];
            if (quoteHit && arg[i - 1] === "\\") {
              reverse += "\\"; // double the slash
            } else if (arg[i - 1] === '"') {
              quoteHit = true;
              reverse += '"'; // double the quote
            } else {
              quoteHit = false;
            }
          }
          reverse += '"';
          return reverse.split("").reverse().join("");
        }
        _uvQuoteCmdArg(arg) {
          // Tool runner wraps child_process.spawn() and needs to apply the same quoting as
          // Node in certain cases where the undocumented spawn option windowsVerbatimArguments
          // is used.
          //
          // Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,
          // see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),
          // pasting copyright notice from Node within this function:
          //
          //      Copyright Joyent, Inc. and other Node contributors. All rights reserved.
          //
          //      Permission is hereby granted, free of charge, to any person obtaining a copy
          //      of this software and associated documentation files (the "Software"), to
          //      deal in the Software without restriction, including without limitation the
          //      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
          //      sell copies of the Software, and to permit persons to whom the Software is
          //      furnished to do so, subject to the following conditions:
          //
          //      The above copyright notice and this permission notice shall be included in
          //      all copies or substantial portions of the Software.
          //
          //      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
          //      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          //      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
          //      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
          //      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
          //      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
          //      IN THE SOFTWARE.
          if (!arg) {
            // Need double quotation for empty argument
            return '""';
          }
          if (!arg.includes(" ") && !arg.includes("\t") && !arg.includes('"')) {
            // No quotation needed
            return arg;
          }
          if (!arg.includes('"') && !arg.includes("\\")) {
            // No embedded double quotes or backslashes, so I can just wrap
            // quote marks around the whole thing.
            return `"${arg}"`;
          }
          // Expected input/output:
          //   input : hello"world
          //   output: "hello\"world"
          //   input : hello""world
          //   output: "hello\"\"world"
          //   input : hello\world
          //   output: hello\world
          //   input : hello\\world
          //   output: hello\\world
          //   input : hello\"world
          //   output: "hello\\\"world"
          //   input : hello\\"world
          //   output: "hello\\\\\"world"
          //   input : hello world\
          //   output: "hello world\\" - note the comment in libuv actually reads "hello world\"
          //                             but it appears the comment is wrong, it should be "hello world\\"
          let reverse = '"';
          let quoteHit = true;
          for (let i = arg.length; i > 0; i--) {
            // walk the string in reverse
            reverse += arg[i - 1];
            if (quoteHit && arg[i - 1] === "\\") {
              reverse += "\\";
            } else if (arg[i - 1] === '"') {
              quoteHit = true;
              reverse += "\\";
            } else {
              quoteHit = false;
            }
          }
          reverse += '"';
          return reverse.split("").reverse().join("");
        }
        _cloneExecOptions(options) {
          options = options || {};
          const result = {
            cwd: options.cwd || process.cwd(),
            env: options.env || process.env,
            silent: options.silent || false,
            windowsVerbatimArguments: options.windowsVerbatimArguments || false,
            failOnStdErr: options.failOnStdErr || false,
            ignoreReturnCode: options.ignoreReturnCode || false,
            delay: options.delay || 10000,
          };
          result.outStream = options.outStream || process.stdout;
          result.errStream = options.errStream || process.stderr;
          return result;
        }
        _getSpawnOptions(options, toolPath) {
          options = options || {};
          const result = {};
          result.cwd = options.cwd;
          result.env = options.env;
          result["windowsVerbatimArguments"] =
            options.windowsVerbatimArguments || this._isCmdFile();
          if (options.windowsVerbatimArguments) {
            result.argv0 = `"${toolPath}"`;
          }
          return result;
        }
        /**
         * Exec a tool.
         * Output will be streamed to the live console.
         * Returns promise with return code
         *
         * @param     tool     path to tool to exec
         * @param     options  optional exec options.  See ExecOptions
         * @returns   number
         */
        exec() {
          return __awaiter(this, void 0, void 0, function* () {
            // root the tool path if it is unrooted and contains relative pathing
            if (
              !ioUtil.isRooted(this.toolPath) &&
              (this.toolPath.includes("/") ||
                (IS_WINDOWS && this.toolPath.includes("\\")))
            ) {
              // prefer options.cwd if it is specified, however options.cwd may also need to be rooted
              this.toolPath = path.resolve(
                process.cwd(),
                this.options.cwd || process.cwd(),
                this.toolPath,
              );
            }
            // if the tool is only a file name, then resolve it from the PATH
            // otherwise verify it exists (add extension on Windows if necessary)
            this.toolPath = yield io.which(this.toolPath, true);
            return new Promise((resolve, reject) =>
              __awaiter(this, void 0, void 0, function* () {
                this._debug(`exec tool: ${this.toolPath}`);
                this._debug("arguments:");
                for (const arg of this.args) {
                  this._debug(`   ${arg}`);
                }
                const optionsNonNull = this._cloneExecOptions(this.options);
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                  optionsNonNull.outStream.write(
                    this._getCommandString(optionsNonNull) + os.EOL,
                  );
                }
                const state = new ExecState(optionsNonNull, this.toolPath);
                state.on("debug", (message) => {
                  this._debug(message);
                });
                if (
                  this.options.cwd &&
                  !(yield ioUtil.exists(this.options.cwd))
                ) {
                  return reject(
                    new Error(`The cwd: ${this.options.cwd} does not exist!`),
                  );
                }
                const fileName = this._getSpawnFileName();
                const cp = child.spawn(
                  fileName,
                  this._getSpawnArgs(optionsNonNull),
                  this._getSpawnOptions(this.options, fileName),
                );
                let stdbuffer = "";
                if (cp.stdout) {
                  cp.stdout.on("data", (data) => {
                    if (
                      this.options.listeners &&
                      this.options.listeners.stdout
                    ) {
                      this.options.listeners.stdout(data);
                    }
                    if (!optionsNonNull.silent && optionsNonNull.outStream) {
                      optionsNonNull.outStream.write(data);
                    }
                    stdbuffer = this._processLineBuffer(
                      data,
                      stdbuffer,
                      (line) => {
                        if (
                          this.options.listeners &&
                          this.options.listeners.stdline
                        ) {
                          this.options.listeners.stdline(line);
                        }
                      },
                    );
                  });
                }
                let errbuffer = "";
                if (cp.stderr) {
                  cp.stderr.on("data", (data) => {
                    state.processStderr = true;
                    if (
                      this.options.listeners &&
                      this.options.listeners.stderr
                    ) {
                      this.options.listeners.stderr(data);
                    }
                    if (
                      !optionsNonNull.silent &&
                      optionsNonNull.errStream &&
                      optionsNonNull.outStream
                    ) {
                      const s = optionsNonNull.failOnStdErr
                        ? optionsNonNull.errStream
                        : optionsNonNull.outStream;
                      s.write(data);
                    }
                    errbuffer = this._processLineBuffer(
                      data,
                      errbuffer,
                      (line) => {
                        if (
                          this.options.listeners &&
                          this.options.listeners.errline
                        ) {
                          this.options.listeners.errline(line);
                        }
                      },
                    );
                  });
                }
                cp.on("error", (err) => {
                  state.processError = err.message;
                  state.processExited = true;
                  state.processClosed = true;
                  state.CheckComplete();
                });
                cp.on("exit", (code) => {
                  state.processExitCode = code;
                  state.processExited = true;
                  this._debug(
                    `Exit code ${code} received from tool '${this.toolPath}'`,
                  );
                  state.CheckComplete();
                });
                cp.on("close", (code) => {
                  state.processExitCode = code;
                  state.processExited = true;
                  state.processClosed = true;
                  this._debug(
                    `STDIO streams have closed for tool '${this.toolPath}'`,
                  );
                  state.CheckComplete();
                });
                state.on("done", (error, exitCode) => {
                  if (stdbuffer.length > 0) {
                    this.emit("stdline", stdbuffer);
                  }
                  if (errbuffer.length > 0) {
                    this.emit("errline", errbuffer);
                  }
                  cp.removeAllListeners();
                  if (error) {
                    reject(error);
                  } else {
                    resolve(exitCode);
                  }
                });
                if (this.options.input) {
                  if (!cp.stdin) {
                    throw new Error("child process missing stdin");
                  }
                  cp.stdin.end(this.options.input);
                }
              }),
            );
          });
        }
      }
      exports.ToolRunner = ToolRunner;
      /**
       * Convert an arg string to an array of args. Handles escaping
       *
       * @param    argString   string of arguments
       * @returns  string[]    array of arguments
       */
      function argStringToArray(argString) {
        const args = [];
        let inQuotes = false;
        let escaped = false;
        let arg = "";
        function append(c) {
          // we only escape double quotes.
          if (escaped && c !== '"') {
            arg += "\\";
          }
          arg += c;
          escaped = false;
        }
        for (let i = 0; i < argString.length; i++) {
          const c = argString.charAt(i);
          if (c === '"') {
            if (!escaped) {
              inQuotes = !inQuotes;
            } else {
              append(c);
            }
            continue;
          }
          if (c === "\\" && escaped) {
            append(c);
            continue;
          }
          if (c === "\\" && inQuotes) {
            escaped = true;
            continue;
          }
          if (c === " " && !inQuotes) {
            if (arg.length > 0) {
              args.push(arg);
              arg = "";
            }
            continue;
          }
          append(c);
        }
        if (arg.length > 0) {
          args.push(arg.trim());
        }
        return args;
      }
      exports.argStringToArray = argStringToArray;
      class ExecState extends events.EventEmitter {
        constructor(options, toolPath) {
          super();
          this.processClosed = false; // tracks whether the process has exited and stdio is closed
          this.processError = "";
          this.processExitCode = 0;
          this.processExited = false; // tracks whether the process has exited
          this.processStderr = false; // tracks whether stderr was written to
          this.delay = 10000; // 10 seconds
          this.done = false;
          this.timeout = null;
          if (!toolPath) {
            throw new Error("toolPath must not be empty");
          }
          this.options = options;
          this.toolPath = toolPath;
          if (options.delay) {
            this.delay = options.delay;
          }
        }
        CheckComplete() {
          if (this.done) {
            return;
          }
          if (this.processClosed) {
            this._setResult();
          } else if (this.processExited) {
            this.timeout = timers_1.setTimeout(
              ExecState.HandleTimeout,
              this.delay,
              this,
            );
          }
        }
        _debug(message) {
          this.emit("debug", message);
        }
        _setResult() {
          // determine whether there is an error
          let error;
          if (this.processExited) {
            if (this.processError) {
              error = new Error(
                `There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`,
              );
            } else if (
              this.processExitCode !== 0 &&
              !this.options.ignoreReturnCode
            ) {
              error = new Error(
                `The process '${this.toolPath}' failed with exit code ${this.processExitCode}`,
              );
            } else if (this.processStderr && this.options.failOnStdErr) {
              error = new Error(
                `The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`,
              );
            }
          }
          // clear the timeout
          if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }
          this.done = true;
          this.emit("done", error, this.processExitCode);
        }
        static HandleTimeout(state) {
          if (state.done) {
            return;
          }
          if (!state.processClosed && state.processExited) {
            const message = `The STDIO streams did not close within ${
              state.delay / 1000
            } seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
            state._debug(message);
          }
          state._setResult();
        }
      }
      //# sourceMappingURL=toolrunner.js.map

      /***/
    },

    /***/ 207: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__,
    ) {
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected);
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next(),
            );
          });
        };
      var _a;
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getCmdPath =
        exports.tryGetExecutablePath =
        exports.isRooted =
        exports.isDirectory =
        exports.exists =
        exports.READONLY =
        exports.UV_FS_O_EXLOCK =
        exports.IS_WINDOWS =
        exports.unlink =
        exports.symlink =
        exports.stat =
        exports.rmdir =
        exports.rm =
        exports.rename =
        exports.readlink =
        exports.readdir =
        exports.open =
        exports.mkdir =
        exports.lstat =
        exports.copyFile =
        exports.chmod =
          void 0;
      const fs = __importStar(__nccwpck_require__(896));
      const path = __importStar(__nccwpck_require__(928));
      ((_a = fs.promises),
        // export const {open} = 'fs'
        (exports.chmod = _a.chmod),
        (exports.copyFile = _a.copyFile),
        (exports.lstat = _a.lstat),
        (exports.mkdir = _a.mkdir),
        (exports.open = _a.open),
        (exports.readdir = _a.readdir),
        (exports.readlink = _a.readlink),
        (exports.rename = _a.rename),
        (exports.rm = _a.rm),
        (exports.rmdir = _a.rmdir),
        (exports.stat = _a.stat),
        (exports.symlink = _a.symlink),
        (exports.unlink = _a.unlink));
      // export const {open} = 'fs'
      exports.IS_WINDOWS = process.platform === "win32";
      // See https://github.com/nodejs/node/blob/d0153aee367422d0858105abec186da4dff0a0c5/deps/uv/include/uv/win.h#L691
      exports.UV_FS_O_EXLOCK = 0x10000000;
      exports.READONLY = fs.constants.O_RDONLY;
      function exists(fsPath) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            yield exports.stat(fsPath);
          } catch (err) {
            if (err.code === "ENOENT") {
              return false;
            }
            throw err;
          }
          return true;
        });
      }
      exports.exists = exists;
      function isDirectory(fsPath, useStat = false) {
        return __awaiter(this, void 0, void 0, function* () {
          const stats = useStat
            ? yield exports.stat(fsPath)
            : yield exports.lstat(fsPath);
          return stats.isDirectory();
        });
      }
      exports.isDirectory = isDirectory;
      /**
       * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:
       * \, \hello, \\hello\share, C:, and C:\hello (and corresponding alternate separator cases).
       */
      function isRooted(p) {
        p = normalizeSeparators(p);
        if (!p) {
          throw new Error('isRooted() parameter "p" cannot be empty');
        }
        if (exports.IS_WINDOWS) {
          return (
            p.startsWith("\\") || /^[A-Z]:/i.test(p) // e.g. \ or \hello or \\hello
          ); // e.g. C: or C:\hello
        }
        return p.startsWith("/");
      }
      exports.isRooted = isRooted;
      /**
       * Best effort attempt to determine whether a file exists and is executable.
       * @param filePath    file path to check
       * @param extensions  additional file extensions to try
       * @return if file exists and is executable, returns the file path. otherwise empty string.
       */
      function tryGetExecutablePath(filePath, extensions) {
        return __awaiter(this, void 0, void 0, function* () {
          let stats = undefined;
          try {
            // test file exists
            stats = yield exports.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              // eslint-disable-next-line no-console
              console.log(
                `Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`,
              );
            }
          }
          if (stats && stats.isFile()) {
            if (exports.IS_WINDOWS) {
              // on Windows, test for valid extension
              const upperExt = path.extname(filePath).toUpperCase();
              if (
                extensions.some(
                  (validExt) => validExt.toUpperCase() === upperExt,
                )
              ) {
                return filePath;
              }
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
          // try each extension
          const originalFilePath = filePath;
          for (const extension of extensions) {
            filePath = originalFilePath + extension;
            stats = undefined;
            try {
              stats = yield exports.stat(filePath);
            } catch (err) {
              if (err.code !== "ENOENT") {
                // eslint-disable-next-line no-console
                console.log(
                  `Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`,
                );
              }
            }
            if (stats && stats.isFile()) {
              if (exports.IS_WINDOWS) {
                // preserve the case of the actual file (since an extension was appended)
                try {
                  const directory = path.dirname(filePath);
                  const upperName = path.basename(filePath).toUpperCase();
                  for (const actualName of yield exports.readdir(directory)) {
                    if (upperName === actualName.toUpperCase()) {
                      filePath = path.join(directory, actualName);
                      break;
                    }
                  }
                } catch (err) {
                  // eslint-disable-next-line no-console
                  console.log(
                    `Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`,
                  );
                }
                return filePath;
              } else {
                if (isUnixExecutable(stats)) {
                  return filePath;
                }
              }
            }
          }
          return "";
        });
      }
      exports.tryGetExecutablePath = tryGetExecutablePath;
      function normalizeSeparators(p) {
        p = p || "";
        if (exports.IS_WINDOWS) {
          // convert slashes on Windows
          p = p.replace(/\//g, "\\");
          // remove redundant slashes
          return p.replace(/\\\\+/g, "\\");
        }
        // remove redundant slashes
        return p.replace(/\/\/+/g, "/");
      }
      // on Mac/Linux, test the execute bit
      //     R   W  X  R  W X R W X
      //   256 128 64 32 16 8 4 2 1
      function isUnixExecutable(stats) {
        return (
          (stats.mode & 1) > 0 ||
          ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||
          ((stats.mode & 64) > 0 && stats.uid === process.getuid())
        );
      }
      // Get the path of cmd.exe in windows
      function getCmdPath() {
        var _a;
        return (_a = process.env["COMSPEC"]) !== null && _a !== void 0
          ? _a
          : `cmd.exe`;
      }
      exports.getCmdPath = getCmdPath;
      //# sourceMappingURL=io-util.js.map

      /***/
    },

    /***/ 994: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__,
    ) {
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected);
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next(),
            );
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findInPath =
        exports.which =
        exports.mkdirP =
        exports.rmRF =
        exports.mv =
        exports.cp =
          void 0;
      const assert_1 = __nccwpck_require__(613);
      const path = __importStar(__nccwpck_require__(928));
      const ioUtil = __importStar(__nccwpck_require__(207));
      /**
       * Copies a file or folder.
       * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js
       *
       * @param     source    source path
       * @param     dest      destination path
       * @param     options   optional. See CopyOptions.
       */
      function cp(source, dest, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const { force, recursive, copySourceDirectory } =
            readCopyOptions(options);
          const destStat = (yield ioUtil.exists(dest))
            ? yield ioUtil.stat(dest)
            : null;
          // Dest is an existing file, but not forcing
          if (destStat && destStat.isFile() && !force) {
            return;
          }
          // If dest is an existing directory, should copy inside.
          const newDest =
            destStat && destStat.isDirectory() && copySourceDirectory
              ? path.join(dest, path.basename(source))
              : dest;
          if (!(yield ioUtil.exists(source))) {
            throw new Error(`no such file or directory: ${source}`);
          }
          const sourceStat = yield ioUtil.stat(source);
          if (sourceStat.isDirectory()) {
            if (!recursive) {
              throw new Error(
                `Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`,
              );
            } else {
              yield cpDirRecursive(source, newDest, 0, force);
            }
          } else {
            if (path.relative(source, newDest) === "") {
              // a file cannot be copied to itself
              throw new Error(`'${newDest}' and '${source}' are the same file`);
            }
            yield copyFile(source, newDest, force);
          }
        });
      }
      exports.cp = cp;
      /**
       * Moves a path.
       *
       * @param     source    source path
       * @param     dest      destination path
       * @param     options   optional. See MoveOptions.
       */
      function mv(source, dest, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          if (yield ioUtil.exists(dest)) {
            let destExists = true;
            if (yield ioUtil.isDirectory(dest)) {
              // If dest is directory copy src into dest
              dest = path.join(dest, path.basename(source));
              destExists = yield ioUtil.exists(dest);
            }
            if (destExists) {
              if (options.force == null || options.force) {
                yield rmRF(dest);
              } else {
                throw new Error("Destination already exists");
              }
            }
          }
          yield mkdirP(path.dirname(dest));
          yield ioUtil.rename(source, dest);
        });
      }
      exports.mv = mv;
      /**
       * Remove a path recursively with force
       *
       * @param inputPath path to remove
       */
      function rmRF(inputPath) {
        return __awaiter(this, void 0, void 0, function* () {
          if (ioUtil.IS_WINDOWS) {
            // Check for invalid characters
            // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file
            if (/[*"<>|]/.test(inputPath)) {
              throw new Error(
                'File path must not contain `*`, `"`, `<`, `>` or `|` on Windows',
              );
            }
          }
          try {
            // note if path does not exist, error is silent
            yield ioUtil.rm(inputPath, {
              force: true,
              maxRetries: 3,
              recursive: true,
              retryDelay: 300,
            });
          } catch (err) {
            throw new Error(`File was unable to be removed ${err}`);
          }
        });
      }
      exports.rmRF = rmRF;
      /**
       * Make a directory.  Creates the full path with folders in between
       * Will throw if it fails
       *
       * @param   fsPath        path to create
       * @returns Promise<void>
       */
      function mkdirP(fsPath) {
        return __awaiter(this, void 0, void 0, function* () {
          assert_1.ok(fsPath, "a path argument must be provided");
          yield ioUtil.mkdir(fsPath, { recursive: true });
        });
      }
      exports.mkdirP = mkdirP;
      /**
       * Returns path of a tool had the tool actually been invoked.  Resolves via paths.
       * If you check and the tool does not exist, it will throw.
       *
       * @param     tool              name of the tool
       * @param     check             whether to check if tool exists
       * @returns   Promise<string>   path to tool
       */
      function which(tool, check) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!tool) {
            throw new Error("parameter 'tool' is required");
          }
          // recursive when check=true
          if (check) {
            const result = yield which(tool, false);
            if (!result) {
              if (ioUtil.IS_WINDOWS) {
                throw new Error(
                  `Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`,
                );
              } else {
                throw new Error(
                  `Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`,
                );
              }
            }
            return result;
          }
          const matches = yield findInPath(tool);
          if (matches && matches.length > 0) {
            return matches[0];
          }
          return "";
        });
      }
      exports.which = which;
      /**
       * Returns a list of all occurrences of the given tool on the system path.
       *
       * @returns   Promise<string[]>  the paths of the tool
       */
      function findInPath(tool) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!tool) {
            throw new Error("parameter 'tool' is required");
          }
          // build the list of extensions to try
          const extensions = [];
          if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
            for (const extension of process.env["PATHEXT"].split(
              path.delimiter,
            )) {
              if (extension) {
                extensions.push(extension);
              }
            }
          }
          // if it's rooted, return it if exists. otherwise return empty.
          if (ioUtil.isRooted(tool)) {
            const filePath = yield ioUtil.tryGetExecutablePath(
              tool,
              extensions,
            );
            if (filePath) {
              return [filePath];
            }
            return [];
          }
          // if any path separators, return empty
          if (tool.includes(path.sep)) {
            return [];
          }
          // build the list of directories
          //
          // Note, technically "where" checks the current directory on Windows. From a toolkit perspective,
          // it feels like we should not do this. Checking the current directory seems like more of a use
          // case of a shell, and the which() function exposed by the toolkit should strive for consistency
          // across platforms.
          const directories = [];
          if (process.env.PATH) {
            for (const p of process.env.PATH.split(path.delimiter)) {
              if (p) {
                directories.push(p);
              }
            }
          }
          // find all matches
          const matches = [];
          for (const directory of directories) {
            const filePath = yield ioUtil.tryGetExecutablePath(
              path.join(directory, tool),
              extensions,
            );
            if (filePath) {
              matches.push(filePath);
            }
          }
          return matches;
        });
      }
      exports.findInPath = findInPath;
      function readCopyOptions(options) {
        const force = options.force == null ? true : options.force;
        const recursive = Boolean(options.recursive);
        const copySourceDirectory =
          options.copySourceDirectory == null
            ? true
            : Boolean(options.copySourceDirectory);
        return { force, recursive, copySourceDirectory };
      }
      function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
        return __awaiter(this, void 0, void 0, function* () {
          // Ensure there is not a run away recursive copy
          if (currentDepth >= 255) return;
          currentDepth++;
          yield mkdirP(destDir);
          const files = yield ioUtil.readdir(sourceDir);
          for (const fileName of files) {
            const srcFile = `${sourceDir}/${fileName}`;
            const destFile = `${destDir}/${fileName}`;
            const srcFileStat = yield ioUtil.lstat(srcFile);
            if (srcFileStat.isDirectory()) {
              // Recurse
              yield cpDirRecursive(srcFile, destFile, currentDepth, force);
            } else {
              yield copyFile(srcFile, destFile, force);
            }
          }
          // Change the mode for the newly created directory
          yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
        });
      }
      // Buffered file copy
      function copyFile(srcFile, destFile, force) {
        return __awaiter(this, void 0, void 0, function* () {
          if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
            // unlink/re-link it
            try {
              yield ioUtil.lstat(destFile);
              yield ioUtil.unlink(destFile);
            } catch (e) {
              // Try to override file permission
              if (e.code === "EPERM") {
                yield ioUtil.chmod(destFile, "0666");
                yield ioUtil.unlink(destFile);
              }
              // other errors = it doesn't exist, no work to do
            }
            // Copy over symlink
            const symlinkFull = yield ioUtil.readlink(srcFile);
            yield ioUtil.symlink(
              symlinkFull,
              destFile,
              ioUtil.IS_WINDOWS ? "junction" : null,
            );
          } else if (!(yield ioUtil.exists(destFile)) || force) {
            yield ioUtil.copyFile(srcFile, destFile);
          }
        });
      }
      //# sourceMappingURL=io.js.map

      /***/
    },

    /***/ 407: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__,
    ) {
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        (function () {
          var ownKeys = function (o) {
            ownKeys =
              Object.getOwnPropertyNames ||
              function (o) {
                var ar = [];
                for (var k in o)
                  if (Object.prototype.hasOwnProperty.call(o, k))
                    ar[ar.length] = k;
                return ar;
              };
            return ownKeys(o);
          };
          return function (mod) {
            if (mod && mod.__esModule) return mod;
            var result = {};
            if (mod != null)
              for (var k = ownKeys(mod), i = 0; i < k.length; i++)
                if (k[i] !== "default") __createBinding(result, mod, k[i]);
            __setModuleDefault(result, mod);
            return result;
          };
        })();
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected);
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next(),
            );
          });
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      const process_1 = __importDefault(__nccwpck_require__(932));
      const exec = __importStar(__nccwpck_require__(236));
      const rest_1 = __nccwpck_require__(380);
      const octokit = new rest_1.Octokit({
        auth: process_1.default.env.GITHUB_TOKEN,
      });
      const delay = (ms) => new Promise((res) => setTimeout(res, ms));
      const [REPO_OWNER, REPO_NAME] =
        process_1.default.env.GITHUB_REPOSITORY.split("/");
      const GITHUB_RUN_ID = process_1.default.env.GITHUB_RUN_ID;
      const HDL_PROJECT_NAME = process_1.default.env.HDL_PROJECT_NAME;
      const GH_OS_TOKEN = process_1.default.env.GH_OS_TOKEN;
      // Method to search for a workflow by name an return the id
      const searchForWorkflowRun = (workflowId, searchName) =>
        __awaiter(void 0, void 0, void 0, function* () {
          let runId = null;
          console.log(`Searching for ${searchName}`);
          while (!runId) {
            const runs = yield octokit.actions.listWorkflowRuns({
              owner: REPO_OWNER,
              repo: REPO_NAME,
              workflow_id: workflowId,
              event: "workflow_dispatch",
              headers: {
                authorization: `token ${GH_OS_TOKEN}`,
              },
            });
            const run = runs.data.workflow_runs.find(
              (r) => r.name === searchName,
            );
            if (run) {
              runId = run.id;
              break;
            }
            console.log("Run not found yet, retrying...");
            yield delay(2000); // Wait before retrying
          }
          if (!runId) {
            throw new Error(
              "Failed to find triggered workflow run ID after multiple attempts.",
            );
          }
          console.log(`Triggered workflow run ID: ${runId}`);
          return runId;
        });
      // Method to monitor testing status - TO BE IMPLEMENTED
      // Method to monitor build workflow and log its status
      const monitorResponseWorkflow = (searchName) =>
        __awaiter(void 0, void 0, void 0, function* () {
          // Search for triggered workflow run by name
          const runId = yield searchForWorkflowRun(
            "get-response.yml",
            searchName,
          );
          // Monitor the workflow run status until it completes
          let status;
          while (status !== "completed") {
            const { data: runData } = yield octokit.actions.getWorkflowRun({
              owner: REPO_OWNER,
              repo: REPO_NAME,
              run_id: runId,
              headers: {
                authorization: `token ${GH_OS_TOKEN}`,
              },
            });
            status = runData.status;
            console.log(`Workflow run status for ${searchName}: ${status}`);
            yield delay(5000); // Wait before checking again
          }
          console.log(`Workflow run completed with conclusion: ${status}`);
        });
      // Method to get data of log build workflow
      const monitorLogWorkflow = (searchName) =>
        __awaiter(void 0, void 0, void 0, function* () {
          // Search for triggered workflow run by name
          const runId = yield searchForWorkflowRun("get-log.yml", searchName);
          // Fetch the logs for the workflow run
          const logsResponse = yield octokit.actions.downloadWorkflowRunLogs({
            owner: REPO_OWNER,
            repo: REPO_NAME,
            run_id: runId,
            headers: {
              authorization: `token ${GH_OS_TOKEN}`,
            },
          });
          console.log(`Logs URL: ${logsResponse.url}`);
          // Download log zip file
          yield exec.exec("mkdir", [searchName]);
          yield exec.exec("wget", [
            "-v",
            "-O",
            `${searchName}/logs.zip`,
            logsResponse.url,
          ]);
          // Unzip and read log file content
          yield exec.exec("unzip", [
            `${searchName}/logs.zip`,
            "-d",
            searchName,
          ]);
          yield exec.exec("cat", [`${searchName}/get-log/2_Get log.txt`]);
        });
      // Main starting point
      (() =>
        __awaiter(void 0, void 0, void 0, function* () {
          try {
            // Check workflow run for build
            yield monitorResponseWorkflow(
              `HDL-Build-for-${HDL_PROJECT_NAME}_${GITHUB_RUN_ID}`,
            );
            yield monitorLogWorkflow(
              `Output-for-HDL-Build-for-${HDL_PROJECT_NAME}_${GITHUB_RUN_ID}`,
            );
            // Check workflow run for publish
            yield monitorResponseWorkflow(
              `HDL-Publish-for-${HDL_PROJECT_NAME}_${GITHUB_RUN_ID}`,
            );
            yield monitorLogWorkflow(
              `Output-for-HDL-Publish-for-${HDL_PROJECT_NAME}_${GITHUB_RUN_ID}`,
            );
          } catch (error) {
            console.error("Error monitoring workflows status:", error);
            process_1.default.exit(1);
          }
        }))();

      /***/
    },

    /***/ 613: /***/ (module) => {
      module.exports = require("assert");

      /***/
    },

    /***/ 317: /***/ (module) => {
      module.exports = require("child_process");

      /***/
    },

    /***/ 434: /***/ (module) => {
      module.exports = require("events");

      /***/
    },

    /***/ 896: /***/ (module) => {
      module.exports = require("fs");

      /***/
    },

    /***/ 857: /***/ (module) => {
      module.exports = require("os");

      /***/
    },

    /***/ 928: /***/ (module) => {
      module.exports = require("path");

      /***/
    },

    /***/ 932: /***/ (module) => {
      module.exports = require("process");

      /***/
    },

    /***/ 193: /***/ (module) => {
      module.exports = require("string_decoder");

      /***/
    },

    /***/ 557: /***/ (module) => {
      module.exports = require("timers");

      /***/
    },

    /***/ 120: /***/ (module) => {
      var __webpack_unused_export__;

      const NullObject = function NullObject() {};
      NullObject.prototype = Object.create(null);

      /**
       * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
       *
       * parameter     = token "=" ( token / quoted-string )
       * token         = 1*tchar
       * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
       *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
       *               / DIGIT / ALPHA
       *               ; any VCHAR, except delimiters
       * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
       * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
       * obs-text      = %x80-FF
       * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
       */
      const paramRE =
        /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;

      /**
       * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
       *
       * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
       * obs-text    = %x80-FF
       */
      const quotedPairRE = /\\([\v\u0020-\u00ff])/gu;

      /**
       * RegExp to match type in RFC 7231 sec 3.1.1.1
       *
       * media-type = type "/" subtype
       * type       = token
       * subtype    = token
       */
      const mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;

      // default ContentType to prevent repeated object creation
      const defaultContentType = { type: "", parameters: new NullObject() };
      Object.freeze(defaultContentType.parameters);
      Object.freeze(defaultContentType);

      /**
       * Parse media type to object.
       *
       * @param {string|object} header
       * @return {Object}
       * @public
       */

      function parse(header) {
        if (typeof header !== "string") {
          throw new TypeError(
            "argument header is required and must be a string",
          );
        }

        let index = header.indexOf(";");
        const type =
          index !== -1 ? header.slice(0, index).trim() : header.trim();

        if (mediaTypeRE.test(type) === false) {
          throw new TypeError("invalid media type");
        }

        const result = {
          type: type.toLowerCase(),
          parameters: new NullObject(),
        };

        // parse parameters
        if (index === -1) {
          return result;
        }

        let key;
        let match;
        let value;

        paramRE.lastIndex = index;

        while ((match = paramRE.exec(header))) {
          if (match.index !== index) {
            throw new TypeError("invalid parameter format");
          }

          index += match[0].length;
          key = match[1].toLowerCase();
          value = match[2];

          if (value[0] === '"') {
            // remove quotes and escapes
            value = value.slice(1, value.length - 1);

            quotedPairRE.test(value) &&
              (value = value.replace(quotedPairRE, "$1"));
          }

          result.parameters[key] = value;
        }

        if (index !== header.length) {
          throw new TypeError("invalid parameter format");
        }

        return result;
      }

      function safeParse(header) {
        if (typeof header !== "string") {
          return defaultContentType;
        }

        let index = header.indexOf(";");
        const type =
          index !== -1 ? header.slice(0, index).trim() : header.trim();

        if (mediaTypeRE.test(type) === false) {
          return defaultContentType;
        }

        const result = {
          type: type.toLowerCase(),
          parameters: new NullObject(),
        };

        // parse parameters
        if (index === -1) {
          return result;
        }

        let key;
        let match;
        let value;

        paramRE.lastIndex = index;

        while ((match = paramRE.exec(header))) {
          if (match.index !== index) {
            return defaultContentType;
          }

          index += match[0].length;
          key = match[1].toLowerCase();
          value = match[2];

          if (value[0] === '"') {
            // remove quotes and escapes
            value = value.slice(1, value.length - 1);

            quotedPairRE.test(value) &&
              (value = value.replace(quotedPairRE, "$1"));
          }

          result.parameters[key] = value;
        }

        if (index !== header.length) {
          return defaultContentType;
        }

        return result;
      }

      __webpack_unused_export__ = { parse, safeParse };
      __webpack_unused_export__ = parse;
      module.exports.xL = safeParse;
      __webpack_unused_export__ = defaultContentType;

      /***/
    },

    /***/ 380: /***/ (
      __unused_webpack___webpack_module__,
      __webpack_exports__,
      __nccwpck_require__,
    ) => {
      // ESM COMPAT FLAG
      __nccwpck_require__.r(__webpack_exports__);

      // EXPORTS
      __nccwpck_require__.d(__webpack_exports__, {
        Octokit: () => /* binding */ dist_src_Octokit,
      }); // CONCATENATED MODULE: ./node_modules/universal-user-agent/index.js

      function getUserAgent() {
        if (typeof navigator === "object" && "userAgent" in navigator) {
          return navigator.userAgent;
        }

        if (typeof process === "object" && process.version !== undefined) {
          return `Node.js/${process.version.substr(1)} (${process.platform}; ${
            process.arch
          })`;
        }

        return "<environment undetectable>";
      } // CONCATENATED MODULE: ./node_modules/before-after-hook/lib/register.js

      // @ts-check

      function register(state, name, method, options) {
        if (typeof method !== "function") {
          throw new Error("method for before hook must be a function");
        }

        if (!options) {
          options = {};
        }

        if (Array.isArray(name)) {
          return name.reverse().reduce((callback, name) => {
            return register.bind(null, state, name, callback, options);
          }, method)();
        }

        return Promise.resolve().then(() => {
          if (!state.registry[name]) {
            return method(options);
          }

          return state.registry[name].reduce((method, registered) => {
            return registered.hook.bind(null, method, options);
          }, method)();
        });
      } // CONCATENATED MODULE: ./node_modules/before-after-hook/lib/add.js

      // @ts-check

      function addHook(state, kind, name, hook) {
        const orig = hook;
        if (!state.registry[name]) {
          state.registry[name] = [];
        }

        if (kind === "before") {
          hook = (method, options) => {
            return Promise.resolve()
              .then(orig.bind(null, options))
              .then(method.bind(null, options));
          };
        }

        if (kind === "after") {
          hook = (method, options) => {
            let result;
            return Promise.resolve()
              .then(method.bind(null, options))
              .then((result_) => {
                result = result_;
                return orig(result, options);
              })
              .then(() => {
                return result;
              });
          };
        }

        if (kind === "error") {
          hook = (method, options) => {
            return Promise.resolve()
              .then(method.bind(null, options))
              .catch((error) => {
                return orig(error, options);
              });
          };
        }

        state.registry[name].push({
          hook: hook,
          orig: orig,
        });
      } // CONCATENATED MODULE: ./node_modules/before-after-hook/lib/remove.js

      // @ts-check

      function removeHook(state, name, method) {
        if (!state.registry[name]) {
          return;
        }

        const index = state.registry[name]
          .map((registered) => {
            return registered.orig;
          })
          .indexOf(method);

        if (index === -1) {
          return;
        }

        state.registry[name].splice(index, 1);
      } // CONCATENATED MODULE: ./node_modules/before-after-hook/index.js

      // @ts-check

      // bind with array of arguments: https://stackoverflow.com/a/21792913
      const bind = Function.bind;
      const bindable = bind.bind(bind);

      function bindApi(hook, state, name) {
        const removeHookRef = bindable(removeHook, null).apply(
          null,
          name ? [state, name] : [state],
        );
        hook.api = { remove: removeHookRef };
        hook.remove = removeHookRef;
        ["before", "error", "after", "wrap"].forEach((kind) => {
          const args = name ? [state, kind, name] : [state, kind];
          hook[kind] = hook.api[kind] = bindable(addHook, null).apply(
            null,
            args,
          );
        });
      }

      function Singular() {
        const singularHookName = Symbol("Singular");
        const singularHookState = {
          registry: {},
        };
        const singularHook = register.bind(
          null,
          singularHookState,
          singularHookName,
        );
        bindApi(singularHook, singularHookState, singularHookName);
        return singularHook;
      }

      function Collection() {
        const state = {
          registry: {},
        };

        const hook = register.bind(null, state);
        bindApi(hook, state);

        return hook;
      }

      /* harmony default export */ const before_after_hook = {
        Singular,
        Collection,
      }; // CONCATENATED MODULE: ./node_modules/@octokit/endpoint/dist-bundle/index.js

      // pkg/dist-src/defaults.js

      // pkg/dist-src/version.js
      var VERSION = "0.0.0-development";

      // pkg/dist-src/defaults.js
      var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
      var DEFAULTS = {
        method: "GET",
        baseUrl: "https://api.github.com",
        headers: {
          accept: "application/vnd.github.v3+json",
          "user-agent": userAgent,
        },
        mediaType: {
          format: "",
        },
      };

      // pkg/dist-src/util/lowercase-keys.js
      function lowercaseKeys(object) {
        if (!object) {
          return {};
        }
        return Object.keys(object).reduce((newObj, key) => {
          newObj[key.toLowerCase()] = object[key];
          return newObj;
        }, {});
      }

      // pkg/dist-src/util/is-plain-object.js
      function isPlainObject(value) {
        if (typeof value !== "object" || value === null) return false;
        if (Object.prototype.toString.call(value) !== "[object Object]")
          return false;
        const proto = Object.getPrototypeOf(value);
        if (proto === null) return true;
        const Ctor =
          Object.prototype.hasOwnProperty.call(proto, "constructor") &&
          proto.constructor;
        return (
          typeof Ctor === "function" &&
          Ctor instanceof Ctor &&
          Function.prototype.call(Ctor) === Function.prototype.call(value)
        );
      }

      // pkg/dist-src/util/merge-deep.js
      function mergeDeep(defaults, options) {
        const result = Object.assign({}, defaults);
        Object.keys(options).forEach((key) => {
          if (isPlainObject(options[key])) {
            if (!(key in defaults))
              Object.assign(result, { [key]: options[key] });
            else result[key] = mergeDeep(defaults[key], options[key]);
          } else {
            Object.assign(result, { [key]: options[key] });
          }
        });
        return result;
      }

      // pkg/dist-src/util/remove-undefined-properties.js
      function removeUndefinedProperties(obj) {
        for (const key in obj) {
          if (obj[key] === void 0) {
            delete obj[key];
          }
        }
        return obj;
      }

      // pkg/dist-src/merge.js
      function merge(defaults, route, options) {
        if (typeof route === "string") {
          let [method, url] = route.split(" ");
          options = Object.assign(
            url ? { method, url } : { url: method },
            options,
          );
        } else {
          options = Object.assign({}, route);
        }
        options.headers = lowercaseKeys(options.headers);
        removeUndefinedProperties(options);
        removeUndefinedProperties(options.headers);
        const mergedOptions = mergeDeep(defaults || {}, options);
        if (options.url === "/graphql") {
          if (defaults && defaults.mediaType.previews?.length) {
            mergedOptions.mediaType.previews = defaults.mediaType.previews
              .filter(
                (preview) =>
                  !mergedOptions.mediaType.previews.includes(preview),
              )
              .concat(mergedOptions.mediaType.previews);
          }
          mergedOptions.mediaType.previews = (
            mergedOptions.mediaType.previews || []
          ).map((preview) => preview.replace(/-preview/, ""));
        }
        return mergedOptions;
      }

      // pkg/dist-src/util/add-query-parameters.js
      function addQueryParameters(url, parameters) {
        const separator = /\?/.test(url) ? "&" : "?";
        const names = Object.keys(parameters);
        if (names.length === 0) {
          return url;
        }
        return (
          url +
          separator +
          names
            .map((name) => {
              if (name === "q") {
                return (
                  "q=" +
                  parameters.q.split("+").map(encodeURIComponent).join("+")
                );
              }
              return `${name}=${encodeURIComponent(parameters[name])}`;
            })
            .join("&")
        );
      }

      // pkg/dist-src/util/extract-url-variable-names.js
      var urlVariableRegex = /\{[^{}}]+\}/g;
      function removeNonChars(variableName) {
        return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
      }
      function extractUrlVariableNames(url) {
        const matches = url.match(urlVariableRegex);
        if (!matches) {
          return [];
        }
        return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
      }

      // pkg/dist-src/util/omit.js
      function omit(object, keysToOmit) {
        const result = { __proto__: null };
        for (const key of Object.keys(object)) {
          if (keysToOmit.indexOf(key) === -1) {
            result[key] = object[key];
          }
        }
        return result;
      }

      // pkg/dist-src/util/url-template.js
      function encodeReserved(str) {
        return str
          .split(/(%[0-9A-Fa-f]{2})/g)
          .map(function (part) {
            if (!/%[0-9A-Fa-f]/.test(part)) {
              part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
            }
            return part;
          })
          .join("");
      }
      function encodeUnreserved(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
          return "%" + c.charCodeAt(0).toString(16).toUpperCase();
        });
      }
      function encodeValue(operator, value, key) {
        value =
          operator === "+" || operator === "#"
            ? encodeReserved(value)
            : encodeUnreserved(value);
        if (key) {
          return encodeUnreserved(key) + "=" + value;
        } else {
          return value;
        }
      }
      function isDefined(value) {
        return value !== void 0 && value !== null;
      }
      function isKeyOperator(operator) {
        return operator === ";" || operator === "&" || operator === "?";
      }
      function getValues(context, operator, key, modifier) {
        var value = context[key],
          result = [];
        if (isDefined(value) && value !== "") {
          if (
            typeof value === "string" ||
            typeof value === "number" ||
            typeof value === "boolean"
          ) {
            value = value.toString();
            if (modifier && modifier !== "*") {
              value = value.substring(0, parseInt(modifier, 10));
            }
            result.push(
              encodeValue(operator, value, isKeyOperator(operator) ? key : ""),
            );
          } else {
            if (modifier === "*") {
              if (Array.isArray(value)) {
                value.filter(isDefined).forEach(function (value2) {
                  result.push(
                    encodeValue(
                      operator,
                      value2,
                      isKeyOperator(operator) ? key : "",
                    ),
                  );
                });
              } else {
                Object.keys(value).forEach(function (k) {
                  if (isDefined(value[k])) {
                    result.push(encodeValue(operator, value[k], k));
                  }
                });
              }
            } else {
              const tmp = [];
              if (Array.isArray(value)) {
                value.filter(isDefined).forEach(function (value2) {
                  tmp.push(encodeValue(operator, value2));
                });
              } else {
                Object.keys(value).forEach(function (k) {
                  if (isDefined(value[k])) {
                    tmp.push(encodeUnreserved(k));
                    tmp.push(encodeValue(operator, value[k].toString()));
                  }
                });
              }
              if (isKeyOperator(operator)) {
                result.push(encodeUnreserved(key) + "=" + tmp.join(","));
              } else if (tmp.length !== 0) {
                result.push(tmp.join(","));
              }
            }
          }
        } else {
          if (operator === ";") {
            if (isDefined(value)) {
              result.push(encodeUnreserved(key));
            }
          } else if (value === "" && (operator === "&" || operator === "?")) {
            result.push(encodeUnreserved(key) + "=");
          } else if (value === "") {
            result.push("");
          }
        }
        return result;
      }
      function parseUrl(template) {
        return {
          expand: expand.bind(null, template),
        };
      }
      function expand(template, context) {
        var operators = ["+", "#", ".", "/", ";", "?", "&"];
        template = template.replace(
          /\{([^\{\}]+)\}|([^\{\}]+)/g,
          function (_, expression, literal) {
            if (expression) {
              let operator = "";
              const values = [];
              if (operators.indexOf(expression.charAt(0)) !== -1) {
                operator = expression.charAt(0);
                expression = expression.substr(1);
              }
              expression.split(/,/g).forEach(function (variable) {
                var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                values.push(
                  getValues(context, operator, tmp[1], tmp[2] || tmp[3]),
                );
              });
              if (operator && operator !== "+") {
                var separator = ",";
                if (operator === "?") {
                  separator = "&";
                } else if (operator !== "#") {
                  separator = operator;
                }
                return (
                  (values.length !== 0 ? operator : "") + values.join(separator)
                );
              } else {
                return values.join(",");
              }
            } else {
              return encodeReserved(literal);
            }
          },
        );
        if (template === "/") {
          return template;
        } else {
          return template.replace(/\/$/, "");
        }
      }

      // pkg/dist-src/parse.js
      function parse(options) {
        let method = options.method.toUpperCase();
        let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
        let headers = Object.assign({}, options.headers);
        let body;
        let parameters = omit(options, [
          "method",
          "baseUrl",
          "url",
          "headers",
          "request",
          "mediaType",
        ]);
        const urlVariableNames = extractUrlVariableNames(url);
        url = parseUrl(url).expand(parameters);
        if (!/^http/.test(url)) {
          url = options.baseUrl + url;
        }
        const omittedParameters = Object.keys(options)
          .filter((option) => urlVariableNames.includes(option))
          .concat("baseUrl");
        const remainingParameters = omit(parameters, omittedParameters);
        const isBinaryRequest = /application\/octet-stream/i.test(
          headers.accept,
        );
        if (!isBinaryRequest) {
          if (options.mediaType.format) {
            headers.accept = headers.accept
              .split(/,/)
              .map((format) =>
                format.replace(
                  /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
                  `application/vnd$1$2.${options.mediaType.format}`,
                ),
              )
              .join(",");
          }
          if (url.endsWith("/graphql")) {
            if (options.mediaType.previews?.length) {
              const previewsFromAcceptHeader =
                headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
              headers.accept = previewsFromAcceptHeader
                .concat(options.mediaType.previews)
                .map((preview) => {
                  const format = options.mediaType.format
                    ? `.${options.mediaType.format}`
                    : "+json";
                  return `application/vnd.github.${preview}-preview${format}`;
                })
                .join(",");
            }
          }
        }
        if (["GET", "HEAD"].includes(method)) {
          url = addQueryParameters(url, remainingParameters);
        } else {
          if ("data" in remainingParameters) {
            body = remainingParameters.data;
          } else {
            if (Object.keys(remainingParameters).length) {
              body = remainingParameters;
            }
          }
        }
        if (!headers["content-type"] && typeof body !== "undefined") {
          headers["content-type"] = "application/json; charset=utf-8";
        }
        if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
          body = "";
        }
        return Object.assign(
          { method, url, headers },
          typeof body !== "undefined" ? { body } : null,
          options.request ? { request: options.request } : null,
        );
      }

      // pkg/dist-src/endpoint-with-defaults.js
      function endpointWithDefaults(defaults, route, options) {
        return parse(merge(defaults, route, options));
      }

      // pkg/dist-src/with-defaults.js
      function withDefaults(oldDefaults, newDefaults) {
        const DEFAULTS2 = merge(oldDefaults, newDefaults);
        const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
        return Object.assign(endpoint2, {
          DEFAULTS: DEFAULTS2,
          defaults: withDefaults.bind(null, DEFAULTS2),
          merge: merge.bind(null, DEFAULTS2),
          parse,
        });
      }

      // pkg/dist-src/index.js
      var endpoint = withDefaults(null, DEFAULTS);

      // EXTERNAL MODULE: ./node_modules/fast-content-type-parse/index.js
      var fast_content_type_parse = __nccwpck_require__(120); // CONCATENATED MODULE: ./node_modules/@octokit/request-error/dist-src/index.js
      class RequestError extends Error {
        name;
        /**
         * http status code
         */
        status;
        /**
         * Request options that lead to the error.
         */
        request;
        /**
         * Response object if a response was received
         */
        response;
        constructor(message, statusCode, options) {
          super(message);
          this.name = "HttpError";
          this.status = Number.parseInt(statusCode);
          if (Number.isNaN(this.status)) {
            this.status = 0;
          }
          if ("response" in options) {
            this.response = options.response;
          }
          const requestCopy = Object.assign({}, options.request);
          if (options.request.headers.authorization) {
            requestCopy.headers = Object.assign({}, options.request.headers, {
              authorization: options.request.headers.authorization.replace(
                /(?<! ) .*$/,
                " [REDACTED]",
              ),
            });
          }
          requestCopy.url = requestCopy.url
            .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]")
            .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
          this.request = requestCopy;
        }
      } // CONCATENATED MODULE: ./node_modules/@octokit/request/dist-bundle/index.js

      // pkg/dist-src/index.js

      // pkg/dist-src/defaults.js

      // pkg/dist-src/version.js
      var dist_bundle_VERSION = "10.0.5";

      // pkg/dist-src/defaults.js
      var defaults_default = {
        headers: {
          "user-agent": `octokit-request.js/${dist_bundle_VERSION} ${getUserAgent()}`,
        },
      };

      // pkg/dist-src/fetch-wrapper.js

      // pkg/dist-src/is-plain-object.js
      function dist_bundle_isPlainObject(value) {
        if (typeof value !== "object" || value === null) return false;
        if (Object.prototype.toString.call(value) !== "[object Object]")
          return false;
        const proto = Object.getPrototypeOf(value);
        if (proto === null) return true;
        const Ctor =
          Object.prototype.hasOwnProperty.call(proto, "constructor") &&
          proto.constructor;
        return (
          typeof Ctor === "function" &&
          Ctor instanceof Ctor &&
          Function.prototype.call(Ctor) === Function.prototype.call(value)
        );
      }

      // pkg/dist-src/fetch-wrapper.js

      async function fetchWrapper(requestOptions) {
        const fetch = requestOptions.request?.fetch || globalThis.fetch;
        if (!fetch) {
          throw new Error(
            "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing",
          );
        }
        const log = requestOptions.request?.log || console;
        const parseSuccessResponseBody =
          requestOptions.request?.parseSuccessResponseBody !== false;
        const body =
          dist_bundle_isPlainObject(requestOptions.body) ||
          Array.isArray(requestOptions.body)
            ? JSON.stringify(requestOptions.body)
            : requestOptions.body;
        const requestHeaders = Object.fromEntries(
          Object.entries(requestOptions.headers).map(([name, value]) => [
            name,
            String(value),
          ]),
        );
        let fetchResponse;
        try {
          fetchResponse = await fetch(requestOptions.url, {
            method: requestOptions.method,
            body,
            redirect: requestOptions.request?.redirect,
            headers: requestHeaders,
            signal: requestOptions.request?.signal,
            // duplex must be set if request.body is ReadableStream or Async Iterables.
            // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
            ...(requestOptions.body && { duplex: "half" }),
          });
        } catch (error) {
          let message = "Unknown Error";
          if (error instanceof Error) {
            if (error.name === "AbortError") {
              error.status = 500;
              throw error;
            }
            message = error.message;
            if (error.name === "TypeError" && "cause" in error) {
              if (error.cause instanceof Error) {
                message = error.cause.message;
              } else if (typeof error.cause === "string") {
                message = error.cause;
              }
            }
          }
          const requestError = new RequestError(message, 500, {
            request: requestOptions,
          });
          requestError.cause = error;
          throw requestError;
        }
        const status = fetchResponse.status;
        const url = fetchResponse.url;
        const responseHeaders = {};
        for (const [key, value] of fetchResponse.headers) {
          responseHeaders[key] = value;
        }
        const octokitResponse = {
          url,
          status,
          headers: responseHeaders,
          data: "",
        };
        if ("deprecation" in responseHeaders) {
          const matches =
            responseHeaders.link &&
            responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
          const deprecationLink = matches && matches.pop();
          log.warn(
            `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`,
          );
        }
        if (status === 204 || status === 205) {
          return octokitResponse;
        }
        if (requestOptions.method === "HEAD") {
          if (status < 400) {
            return octokitResponse;
          }
          throw new RequestError(fetchResponse.statusText, status, {
            response: octokitResponse,
            request: requestOptions,
          });
        }
        if (status === 304) {
          octokitResponse.data = await getResponseData(fetchResponse);
          throw new RequestError("Not modified", status, {
            response: octokitResponse,
            request: requestOptions,
          });
        }
        if (status >= 400) {
          octokitResponse.data = await getResponseData(fetchResponse);
          throw new RequestError(toErrorMessage(octokitResponse.data), status, {
            response: octokitResponse,
            request: requestOptions,
          });
        }
        octokitResponse.data = parseSuccessResponseBody
          ? await getResponseData(fetchResponse)
          : fetchResponse.body;
        return octokitResponse;
      }
      async function getResponseData(response) {
        const contentType = response.headers.get("content-type");
        if (!contentType) {
          return response.text().catch(() => "");
        }
        const mimetype = (0, fast_content_type_parse /* safeParse */.xL)(
          contentType,
        );
        if (isJSONResponse(mimetype)) {
          let text = "";
          try {
            text = await response.text();
            return JSON.parse(text);
          } catch (err) {
            return text;
          }
        } else if (
          mimetype.type.startsWith("text/") ||
          mimetype.parameters.charset?.toLowerCase() === "utf-8"
        ) {
          return response.text().catch(() => "");
        } else {
          return response.arrayBuffer().catch(() => new ArrayBuffer(0));
        }
      }
      function isJSONResponse(mimetype) {
        return (
          mimetype.type === "application/json" ||
          mimetype.type === "application/scim+json"
        );
      }
      function toErrorMessage(data) {
        if (typeof data === "string") {
          return data;
        }
        if (data instanceof ArrayBuffer) {
          return "Unknown error";
        }
        if ("message" in data) {
          const suffix =
            "documentation_url" in data ? ` - ${data.documentation_url}` : "";
          return Array.isArray(data.errors)
            ? `${data.message}: ${data.errors.map((v) => JSON.stringify(v)).join(", ")}${suffix}`
            : `${data.message}${suffix}`;
        }
        return `Unknown error: ${JSON.stringify(data)}`;
      }

      // pkg/dist-src/with-defaults.js
      function dist_bundle_withDefaults(oldEndpoint, newDefaults) {
        const endpoint2 = oldEndpoint.defaults(newDefaults);
        const newApi = function (route, parameters) {
          const endpointOptions = endpoint2.merge(route, parameters);
          if (!endpointOptions.request || !endpointOptions.request.hook) {
            return fetchWrapper(endpoint2.parse(endpointOptions));
          }
          const request2 = (route2, parameters2) => {
            return fetchWrapper(
              endpoint2.parse(endpoint2.merge(route2, parameters2)),
            );
          };
          Object.assign(request2, {
            endpoint: endpoint2,
            defaults: dist_bundle_withDefaults.bind(null, endpoint2),
          });
          return endpointOptions.request.hook(request2, endpointOptions);
        };
        return Object.assign(newApi, {
          endpoint: endpoint2,
          defaults: dist_bundle_withDefaults.bind(null, endpoint2),
        });
      }

      // pkg/dist-src/index.js
      var request = dist_bundle_withDefaults(endpoint, defaults_default); // CONCATENATED MODULE: ./node_modules/@octokit/graphql/dist-bundle/index.js

      // pkg/dist-src/index.js

      // pkg/dist-src/version.js
      var graphql_dist_bundle_VERSION = "0.0.0-development";

      // pkg/dist-src/with-defaults.js

      // pkg/dist-src/graphql.js

      // pkg/dist-src/error.js
      function _buildMessageForResponseErrors(data) {
        return (
          `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n")
        );
      }
      var GraphqlResponseError = class extends Error {
        constructor(request2, headers, response) {
          super(_buildMessageForResponseErrors(response));
          this.request = request2;
          this.headers = headers;
          this.response = response;
          this.errors = response.errors;
          this.data = response.data;
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
        }
        name = "GraphqlResponseError";
        errors;
        data;
      };

      // pkg/dist-src/graphql.js
      var NON_VARIABLE_OPTIONS = [
        "method",
        "baseUrl",
        "url",
        "headers",
        "request",
        "query",
        "mediaType",
        "operationName",
      ];
      var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
      var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
      function graphql(request2, query, options) {
        if (options) {
          if (typeof query === "string" && "query" in options) {
            return Promise.reject(
              new Error(
                `[@octokit/graphql] "query" cannot be used as variable name`,
              ),
            );
          }
          for (const key in options) {
            if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
            return Promise.reject(
              new Error(
                `[@octokit/graphql] "${key}" cannot be used as variable name`,
              ),
            );
          }
        }
        const parsedOptions =
          typeof query === "string" ? Object.assign({ query }, options) : query;
        const requestOptions = Object.keys(parsedOptions).reduce(
          (result, key) => {
            if (NON_VARIABLE_OPTIONS.includes(key)) {
              result[key] = parsedOptions[key];
              return result;
            }
            if (!result.variables) {
              result.variables = {};
            }
            result.variables[key] = parsedOptions[key];
            return result;
          },
          {},
        );
        const baseUrl =
          parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
        if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
          requestOptions.url = baseUrl.replace(
            GHES_V3_SUFFIX_REGEX,
            "/api/graphql",
          );
        }
        return request2(requestOptions).then((response) => {
          if (response.data.errors) {
            const headers = {};
            for (const key of Object.keys(response.headers)) {
              headers[key] = response.headers[key];
            }
            throw new GraphqlResponseError(
              requestOptions,
              headers,
              response.data,
            );
          }
          return response.data.data;
        });
      }

      // pkg/dist-src/with-defaults.js
      function graphql_dist_bundle_withDefaults(request2, newDefaults) {
        const newRequest = request2.defaults(newDefaults);
        const newApi = (query, options) => {
          return graphql(newRequest, query, options);
        };
        return Object.assign(newApi, {
          defaults: graphql_dist_bundle_withDefaults.bind(null, newRequest),
          endpoint: newRequest.endpoint,
        });
      }

      // pkg/dist-src/index.js
      var graphql2 = graphql_dist_bundle_withDefaults(request, {
        headers: {
          "user-agent": `octokit-graphql.js/${graphql_dist_bundle_VERSION} ${getUserAgent()}`,
        },
        method: "POST",
        url: "/graphql",
      });
      function withCustomRequest(customRequest) {
        return graphql_dist_bundle_withDefaults(customRequest, {
          method: "POST",
          url: "/graphql",
        });
      } // CONCATENATED MODULE: ./node_modules/@octokit/auth-token/dist-bundle/index.js

      // pkg/dist-src/is-jwt.js
      var b64url = "(?:[a-zA-Z0-9_-]+)";
      var sep = "\\.";
      var jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);
      var isJWT = jwtRE.test.bind(jwtRE);

      // pkg/dist-src/auth.js
      async function auth(token) {
        const isApp = isJWT(token);
        const isInstallation =
          token.startsWith("v1.") || token.startsWith("ghs_");
        const isUserToServer = token.startsWith("ghu_");
        const tokenType = isApp
          ? "app"
          : isInstallation
            ? "installation"
            : isUserToServer
              ? "user-to-server"
              : "oauth";
        return {
          type: "token",
          token,
          tokenType,
        };
      }

      // pkg/dist-src/with-authorization-prefix.js
      function withAuthorizationPrefix(token) {
        if (token.split(/\./).length === 3) {
          return `bearer ${token}`;
        }
        return `token ${token}`;
      }

      // pkg/dist-src/hook.js
      async function hook(token, request, route, parameters) {
        const endpoint = request.endpoint.merge(route, parameters);
        endpoint.headers.authorization = withAuthorizationPrefix(token);
        return request(endpoint);
      }

      // pkg/dist-src/index.js
      var createTokenAuth = function createTokenAuth2(token) {
        if (!token) {
          throw new Error(
            "[@octokit/auth-token] No token passed to createTokenAuth",
          );
        }
        if (typeof token !== "string") {
          throw new Error(
            "[@octokit/auth-token] Token passed to createTokenAuth is not a string",
          );
        }
        token = token.replace(/^(token|bearer) +/i, "");
        return Object.assign(auth.bind(null, token), {
          hook: hook.bind(null, token),
        });
      }; // CONCATENATED MODULE: ./node_modules/@octokit/core/dist-src/version.js

      const version_VERSION = "7.0.5"; // CONCATENATED MODULE: ./node_modules/@octokit/core/dist-src/index.js

      const noop = () => {};
      const consoleWarn = console.warn.bind(console);
      const consoleError = console.error.bind(console);
      function createLogger(logger = {}) {
        if (typeof logger.debug !== "function") {
          logger.debug = noop;
        }
        if (typeof logger.info !== "function") {
          logger.info = noop;
        }
        if (typeof logger.warn !== "function") {
          logger.warn = consoleWarn;
        }
        if (typeof logger.error !== "function") {
          logger.error = consoleError;
        }
        return logger;
      }
      const userAgentTrail = `octokit-core.js/${version_VERSION} ${getUserAgent()}`;
      class Octokit {
        static VERSION = version_VERSION;
        static defaults(defaults) {
          const OctokitWithDefaults = class extends this {
            constructor(...args) {
              const options = args[0] || {};
              if (typeof defaults === "function") {
                super(defaults(options));
                return;
              }
              super(
                Object.assign(
                  {},
                  defaults,
                  options,
                  options.userAgent && defaults.userAgent
                    ? {
                        userAgent: `${options.userAgent} ${defaults.userAgent}`,
                      }
                    : null,
                ),
              );
            }
          };
          return OctokitWithDefaults;
        }
        static plugins = [];
        /**
         * Attach a plugin (or many) to your Octokit instance.
         *
         * @example
         * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
         */
        static plugin(...newPlugins) {
          const currentPlugins = this.plugins;
          const NewOctokit = class extends this {
            static plugins = currentPlugins.concat(
              newPlugins.filter((plugin) => !currentPlugins.includes(plugin)),
            );
          };
          return NewOctokit;
        }
        constructor(options = {}) {
          const hook = new before_after_hook.Collection();
          const requestDefaults = {
            baseUrl: request.endpoint.DEFAULTS.baseUrl,
            headers: {},
            request: Object.assign({}, options.request, {
              // @ts-ignore internal usage only, no need to type
              hook: hook.bind(null, "request"),
            }),
            mediaType: {
              previews: [],
              format: "",
            },
          };
          requestDefaults.headers["user-agent"] = options.userAgent
            ? `${options.userAgent} ${userAgentTrail}`
            : userAgentTrail;
          if (options.baseUrl) {
            requestDefaults.baseUrl = options.baseUrl;
          }
          if (options.previews) {
            requestDefaults.mediaType.previews = options.previews;
          }
          if (options.timeZone) {
            requestDefaults.headers["time-zone"] = options.timeZone;
          }
          this.request = request.defaults(requestDefaults);
          this.graphql = withCustomRequest(this.request).defaults(
            requestDefaults,
          );
          this.log = createLogger(options.log);
          this.hook = hook;
          if (!options.authStrategy) {
            if (!options.auth) {
              this.auth = async () => ({
                type: "unauthenticated",
              });
            } else {
              const auth = createTokenAuth(options.auth);
              hook.wrap("request", auth.hook);
              this.auth = auth;
            }
          } else {
            const { authStrategy, ...otherOptions } = options;
            const auth = authStrategy(
              Object.assign(
                {
                  request: this.request,
                  log: this.log,
                  // we pass the current octokit instance as well as its constructor options
                  // to allow for authentication strategies that return a new octokit instance
                  // that shares the same internal state as the current one. The original
                  // requirement for this was the "event-octokit" authentication strategy
                  // of https://github.com/probot/octokit-auth-probot.
                  octokit: this,
                  octokitOptions: otherOptions,
                },
                options.auth,
              ),
            );
            hook.wrap("request", auth.hook);
            this.auth = auth;
          }
          const classConstructor = this.constructor;
          for (let i = 0; i < classConstructor.plugins.length; ++i) {
            Object.assign(this, classConstructor.plugins[i](this, options));
          }
        }
        // assigned during constructor
        request;
        graphql;
        log;
        hook;
        // TODO: type `octokit.auth` based on passed options.authStrategy
        auth;
      } // CONCATENATED MODULE: ./node_modules/@octokit/plugin-request-log/dist-src/version.js

      const dist_src_version_VERSION = "6.0.0"; // CONCATENATED MODULE: ./node_modules/@octokit/plugin-request-log/dist-src/index.js

      function requestLog(octokit) {
        octokit.hook.wrap("request", (request, options) => {
          octokit.log.debug("request", options);
          const start = Date.now();
          const requestOptions = octokit.request.endpoint.parse(options);
          const path = requestOptions.url.replace(options.baseUrl, "");
          return request(options)
            .then((response) => {
              const requestId = response.headers["x-github-request-id"];
              octokit.log.info(
                `${requestOptions.method} ${path} - ${response.status} with id ${requestId} in ${Date.now() - start}ms`,
              );
              return response;
            })
            .catch((error) => {
              const requestId =
                error.response?.headers["x-github-request-id"] || "UNKNOWN";
              octokit.log.error(
                `${requestOptions.method} ${path} - ${error.status} with id ${requestId} in ${Date.now() - start}ms`,
              );
              throw error;
            });
        });
      }
      requestLog.VERSION = dist_src_version_VERSION; // CONCATENATED MODULE: ./node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js

      // pkg/dist-src/version.js
      var plugin_paginate_rest_dist_bundle_VERSION = "0.0.0-development";

      // pkg/dist-src/normalize-paginated-list-response.js
      function normalizePaginatedListResponse(response) {
        if (!response.data) {
          return {
            ...response,
            data: [],
          };
        }
        const responseNeedsNormalization =
          ("total_count" in response.data ||
            "total_commits" in response.data) &&
          !("url" in response.data);
        if (!responseNeedsNormalization) return response;
        const incompleteResults = response.data.incomplete_results;
        const repositorySelection = response.data.repository_selection;
        const totalCount = response.data.total_count;
        const totalCommits = response.data.total_commits;
        delete response.data.incomplete_results;
        delete response.data.repository_selection;
        delete response.data.total_count;
        delete response.data.total_commits;
        const namespaceKey = Object.keys(response.data)[0];
        const data = response.data[namespaceKey];
        response.data = data;
        if (typeof incompleteResults !== "undefined") {
          response.data.incomplete_results = incompleteResults;
        }
        if (typeof repositorySelection !== "undefined") {
          response.data.repository_selection = repositorySelection;
        }
        response.data.total_count = totalCount;
        response.data.total_commits = totalCommits;
        return response;
      }

      // pkg/dist-src/iterator.js
      function iterator(octokit, route, parameters) {
        const options =
          typeof route === "function"
            ? route.endpoint(parameters)
            : octokit.request.endpoint(route, parameters);
        const requestMethod =
          typeof route === "function" ? route : octokit.request;
        const method = options.method;
        const headers = options.headers;
        let url = options.url;
        return {
          [Symbol.asyncIterator]: () => ({
            async next() {
              if (!url) return { done: true };
              try {
                const response = await requestMethod({ method, url, headers });
                const normalizedResponse =
                  normalizePaginatedListResponse(response);
                url = ((normalizedResponse.headers.link || "").match(
                  /<([^<>]+)>;\s*rel="next"/,
                ) || [])[1];
                if (!url && "total_commits" in normalizedResponse.data) {
                  const parsedUrl = new URL(normalizedResponse.url);
                  const params = parsedUrl.searchParams;
                  const page = parseInt(params.get("page") || "1", 10);
                  const per_page = parseInt(
                    params.get("per_page") || "250",
                    10,
                  );
                  if (page * per_page < normalizedResponse.data.total_commits) {
                    params.set("page", String(page + 1));
                    url = parsedUrl.toString();
                  }
                }
                return { value: normalizedResponse };
              } catch (error) {
                if (error.status !== 409) throw error;
                url = "";
                return {
                  value: {
                    status: 200,
                    headers: {},
                    data: [],
                  },
                };
              }
            },
          }),
        };
      }

      // pkg/dist-src/paginate.js
      function paginate(octokit, route, parameters, mapFn) {
        if (typeof parameters === "function") {
          mapFn = parameters;
          parameters = void 0;
        }
        return gather(
          octokit,
          [],
          iterator(octokit, route, parameters)[Symbol.asyncIterator](),
          mapFn,
        );
      }
      function gather(octokit, results, iterator2, mapFn) {
        return iterator2.next().then((result) => {
          if (result.done) {
            return results;
          }
          let earlyExit = false;
          function done() {
            earlyExit = true;
          }
          results = results.concat(
            mapFn ? mapFn(result.value, done) : result.value.data,
          );
          if (earlyExit) {
            return results;
          }
          return gather(octokit, results, iterator2, mapFn);
        });
      }

      // pkg/dist-src/compose-paginate.js
      var composePaginateRest = Object.assign(paginate, {
        iterator,
      });

      // pkg/dist-src/generated/paginating-endpoints.js
      var paginatingEndpoints = /* unused pure expression or super */ null && [
        "GET /advisories",
        "GET /app/hook/deliveries",
        "GET /app/installation-requests",
        "GET /app/installations",
        "GET /assignments/{assignment_id}/accepted_assignments",
        "GET /classrooms",
        "GET /classrooms/{classroom_id}/assignments",
        "GET /enterprises/{enterprise}/code-security/configurations",
        "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories",
        "GET /enterprises/{enterprise}/dependabot/alerts",
        "GET /enterprises/{enterprise}/secret-scanning/alerts",
        "GET /events",
        "GET /gists",
        "GET /gists/public",
        "GET /gists/starred",
        "GET /gists/{gist_id}/comments",
        "GET /gists/{gist_id}/commits",
        "GET /gists/{gist_id}/forks",
        "GET /installation/repositories",
        "GET /issues",
        "GET /licenses",
        "GET /marketplace_listing/plans",
        "GET /marketplace_listing/plans/{plan_id}/accounts",
        "GET /marketplace_listing/stubbed/plans",
        "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
        "GET /networks/{owner}/{repo}/events",
        "GET /notifications",
        "GET /organizations",
        "GET /organizations/{org}/dependabot/repository-access",
        "GET /orgs/{org}/actions/cache/usage-by-repository",
        "GET /orgs/{org}/actions/hosted-runners",
        "GET /orgs/{org}/actions/permissions/repositories",
        "GET /orgs/{org}/actions/permissions/self-hosted-runners/repositories",
        "GET /orgs/{org}/actions/runner-groups",
        "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners",
        "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories",
        "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners",
        "GET /orgs/{org}/actions/runners",
        "GET /orgs/{org}/actions/secrets",
        "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
        "GET /orgs/{org}/actions/variables",
        "GET /orgs/{org}/actions/variables/{name}/repositories",
        "GET /orgs/{org}/attestations/{subject_digest}",
        "GET /orgs/{org}/blocks",
        "GET /orgs/{org}/campaigns",
        "GET /orgs/{org}/code-scanning/alerts",
        "GET /orgs/{org}/code-security/configurations",
        "GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories",
        "GET /orgs/{org}/codespaces",
        "GET /orgs/{org}/codespaces/secrets",
        "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
        "GET /orgs/{org}/copilot/billing/seats",
        "GET /orgs/{org}/copilot/metrics",
        "GET /orgs/{org}/dependabot/alerts",
        "GET /orgs/{org}/dependabot/secrets",
        "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
        "GET /orgs/{org}/events",
        "GET /orgs/{org}/failed_invitations",
        "GET /orgs/{org}/hooks",
        "GET /orgs/{org}/hooks/{hook_id}/deliveries",
        "GET /orgs/{org}/insights/api/route-stats/{actor_type}/{actor_id}",
        "GET /orgs/{org}/insights/api/subject-stats",
        "GET /orgs/{org}/insights/api/user-stats/{user_id}",
        "GET /orgs/{org}/installations",
        "GET /orgs/{org}/invitations",
        "GET /orgs/{org}/invitations/{invitation_id}/teams",
        "GET /orgs/{org}/issues",
        "GET /orgs/{org}/members",
        "GET /orgs/{org}/members/{username}/codespaces",
        "GET /orgs/{org}/migrations",
        "GET /orgs/{org}/migrations/{migration_id}/repositories",
        "GET /orgs/{org}/organization-roles/{role_id}/teams",
        "GET /orgs/{org}/organization-roles/{role_id}/users",
        "GET /orgs/{org}/outside_collaborators",
        "GET /orgs/{org}/packages",
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
        "GET /orgs/{org}/personal-access-token-requests",
        "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
        "GET /orgs/{org}/personal-access-tokens",
        "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
        "GET /orgs/{org}/private-registries",
        "GET /orgs/{org}/projects",
        "GET /orgs/{org}/projectsV2",
        "GET /orgs/{org}/projectsV2/{project_number}/fields",
        "GET /orgs/{org}/projectsV2/{project_number}/items",
        "GET /orgs/{org}/properties/values",
        "GET /orgs/{org}/public_members",
        "GET /orgs/{org}/repos",
        "GET /orgs/{org}/rulesets",
        "GET /orgs/{org}/rulesets/rule-suites",
        "GET /orgs/{org}/rulesets/{ruleset_id}/history",
        "GET /orgs/{org}/secret-scanning/alerts",
        "GET /orgs/{org}/security-advisories",
        "GET /orgs/{org}/settings/network-configurations",
        "GET /orgs/{org}/team/{team_slug}/copilot/metrics",
        "GET /orgs/{org}/teams",
        "GET /orgs/{org}/teams/{team_slug}/discussions",
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
        "GET /orgs/{org}/teams/{team_slug}/invitations",
        "GET /orgs/{org}/teams/{team_slug}/members",
        "GET /orgs/{org}/teams/{team_slug}/projects",
        "GET /orgs/{org}/teams/{team_slug}/repos",
        "GET /orgs/{org}/teams/{team_slug}/teams",
        "GET /projects/{project_id}/collaborators",
        "GET /projects/{project_id}/columns",
        "GET /repos/{owner}/{repo}/actions/artifacts",
        "GET /repos/{owner}/{repo}/actions/caches",
        "GET /repos/{owner}/{repo}/actions/organization-secrets",
        "GET /repos/{owner}/{repo}/actions/organization-variables",
        "GET /repos/{owner}/{repo}/actions/runners",
        "GET /repos/{owner}/{repo}/actions/runs",
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
        "GET /repos/{owner}/{repo}/actions/secrets",
        "GET /repos/{owner}/{repo}/actions/variables",
        "GET /repos/{owner}/{repo}/actions/workflows",
        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
        "GET /repos/{owner}/{repo}/activity",
        "GET /repos/{owner}/{repo}/assignees",
        "GET /repos/{owner}/{repo}/attestations/{subject_digest}",
        "GET /repos/{owner}/{repo}/branches",
        "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
        "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
        "GET /repos/{owner}/{repo}/code-scanning/alerts",
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
        "GET /repos/{owner}/{repo}/code-scanning/analyses",
        "GET /repos/{owner}/{repo}/codespaces",
        "GET /repos/{owner}/{repo}/codespaces/devcontainers",
        "GET /repos/{owner}/{repo}/codespaces/secrets",
        "GET /repos/{owner}/{repo}/collaborators",
        "GET /repos/{owner}/{repo}/comments",
        "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
        "GET /repos/{owner}/{repo}/commits",
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
        "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
        "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
        "GET /repos/{owner}/{repo}/commits/{ref}/status",
        "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
        "GET /repos/{owner}/{repo}/compare/{basehead}",
        "GET /repos/{owner}/{repo}/compare/{base}...{head}",
        "GET /repos/{owner}/{repo}/contributors",
        "GET /repos/{owner}/{repo}/dependabot/alerts",
        "GET /repos/{owner}/{repo}/dependabot/secrets",
        "GET /repos/{owner}/{repo}/deployments",
        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
        "GET /repos/{owner}/{repo}/environments",
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
        "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets",
        "GET /repos/{owner}/{repo}/environments/{environment_name}/variables",
        "GET /repos/{owner}/{repo}/events",
        "GET /repos/{owner}/{repo}/forks",
        "GET /repos/{owner}/{repo}/hooks",
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
        "GET /repos/{owner}/{repo}/invitations",
        "GET /repos/{owner}/{repo}/issues",
        "GET /repos/{owner}/{repo}/issues/comments",
        "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
        "GET /repos/{owner}/{repo}/issues/events",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocking",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues",
        "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
        "GET /repos/{owner}/{repo}/keys",
        "GET /repos/{owner}/{repo}/labels",
        "GET /repos/{owner}/{repo}/milestones",
        "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
        "GET /repos/{owner}/{repo}/notifications",
        "GET /repos/{owner}/{repo}/pages/builds",
        "GET /repos/{owner}/{repo}/projects",
        "GET /repos/{owner}/{repo}/pulls",
        "GET /repos/{owner}/{repo}/pulls/comments",
        "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
        "GET /repos/{owner}/{repo}/releases",
        "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
        "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
        "GET /repos/{owner}/{repo}/rules/branches/{branch}",
        "GET /repos/{owner}/{repo}/rulesets",
        "GET /repos/{owner}/{repo}/rulesets/rule-suites",
        "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history",
        "GET /repos/{owner}/{repo}/secret-scanning/alerts",
        "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
        "GET /repos/{owner}/{repo}/security-advisories",
        "GET /repos/{owner}/{repo}/stargazers",
        "GET /repos/{owner}/{repo}/subscribers",
        "GET /repos/{owner}/{repo}/tags",
        "GET /repos/{owner}/{repo}/teams",
        "GET /repos/{owner}/{repo}/topics",
        "GET /repositories",
        "GET /search/code",
        "GET /search/commits",
        "GET /search/issues",
        "GET /search/labels",
        "GET /search/repositories",
        "GET /search/topics",
        "GET /search/users",
        "GET /teams/{team_id}/discussions",
        "GET /teams/{team_id}/discussions/{discussion_number}/comments",
        "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
        "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
        "GET /teams/{team_id}/invitations",
        "GET /teams/{team_id}/members",
        "GET /teams/{team_id}/projects",
        "GET /teams/{team_id}/repos",
        "GET /teams/{team_id}/teams",
        "GET /user/blocks",
        "GET /user/codespaces",
        "GET /user/codespaces/secrets",
        "GET /user/emails",
        "GET /user/followers",
        "GET /user/following",
        "GET /user/gpg_keys",
        "GET /user/installations",
        "GET /user/installations/{installation_id}/repositories",
        "GET /user/issues",
        "GET /user/keys",
        "GET /user/marketplace_purchases",
        "GET /user/marketplace_purchases/stubbed",
        "GET /user/memberships/orgs",
        "GET /user/migrations",
        "GET /user/migrations/{migration_id}/repositories",
        "GET /user/orgs",
        "GET /user/packages",
        "GET /user/packages/{package_type}/{package_name}/versions",
        "GET /user/public_emails",
        "GET /user/repos",
        "GET /user/repository_invitations",
        "GET /user/social_accounts",
        "GET /user/ssh_signing_keys",
        "GET /user/starred",
        "GET /user/subscriptions",
        "GET /user/teams",
        "GET /users",
        "GET /users/{user_id}/projectsV2/{project_number}/fields",
        "GET /users/{user_id}/projectsV2/{project_number}/items",
        "GET /users/{username}/attestations/{subject_digest}",
        "GET /users/{username}/events",
        "GET /users/{username}/events/orgs/{org}",
        "GET /users/{username}/events/public",
        "GET /users/{username}/followers",
        "GET /users/{username}/following",
        "GET /users/{username}/gists",
        "GET /users/{username}/gpg_keys",
        "GET /users/{username}/keys",
        "GET /users/{username}/orgs",
        "GET /users/{username}/packages",
        "GET /users/{username}/projects",
        "GET /users/{username}/projectsV2",
        "GET /users/{username}/received_events",
        "GET /users/{username}/received_events/public",
        "GET /users/{username}/repos",
        "GET /users/{username}/social_accounts",
        "GET /users/{username}/ssh_signing_keys",
        "GET /users/{username}/starred",
        "GET /users/{username}/subscriptions",
      ];

      // pkg/dist-src/paginating-endpoints.js
      function isPaginatingEndpoint(arg) {
        if (typeof arg === "string") {
          return paginatingEndpoints.includes(arg);
        } else {
          return false;
        }
      }

      // pkg/dist-src/index.js
      function paginateRest(octokit) {
        return {
          paginate: Object.assign(paginate.bind(null, octokit), {
            iterator: iterator.bind(null, octokit),
          }),
        };
      }
      paginateRest.VERSION = plugin_paginate_rest_dist_bundle_VERSION; // CONCATENATED MODULE: ./node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js

      const plugin_rest_endpoint_methods_dist_src_version_VERSION = "16.1.0"; // CONCATENATED MODULE: ./node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js

      //# sourceMappingURL=version.js.map

      const Endpoints = {
        actions: {
          addCustomLabelsToSelfHostedRunnerForOrg: [
            "POST /orgs/{org}/actions/runners/{runner_id}/labels",
          ],
          addCustomLabelsToSelfHostedRunnerForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
          ],
          addRepoAccessToSelfHostedRunnerGroupInOrg: [
            "PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}",
          ],
          addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
          ],
          addSelectedRepoToOrgVariable: [
            "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}",
          ],
          approveWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve",
          ],
          cancelWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel",
          ],
          createEnvironmentVariable: [
            "POST /repos/{owner}/{repo}/environments/{environment_name}/variables",
          ],
          createHostedRunnerForOrg: ["POST /orgs/{org}/actions/hosted-runners"],
          createOrUpdateEnvironmentSecret: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}",
          ],
          createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}",
          ],
          createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}",
          ],
          createOrgVariable: ["POST /orgs/{org}/actions/variables"],
          createRegistrationTokenForOrg: [
            "POST /orgs/{org}/actions/runners/registration-token",
          ],
          createRegistrationTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/registration-token",
          ],
          createRemoveTokenForOrg: [
            "POST /orgs/{org}/actions/runners/remove-token",
          ],
          createRemoveTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/remove-token",
          ],
          createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
          createWorkflowDispatch: [
            "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches",
          ],
          deleteActionsCacheById: [
            "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}",
          ],
          deleteActionsCacheByKey: [
            "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}",
          ],
          deleteArtifact: [
            "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}",
          ],
          deleteEnvironmentSecret: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}",
          ],
          deleteEnvironmentVariable: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}",
          ],
          deleteHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}",
          ],
          deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
          deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
          deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}",
          ],
          deleteRepoVariable: [
            "DELETE /repos/{owner}/{repo}/actions/variables/{name}",
          ],
          deleteSelfHostedRunnerFromOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}",
          ],
          deleteSelfHostedRunnerFromRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}",
          ],
          deleteWorkflowRun: [
            "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}",
          ],
          deleteWorkflowRunLogs: [
            "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
          ],
          disableSelectedRepositoryGithubActionsOrganization: [
            "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}",
          ],
          disableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable",
          ],
          downloadArtifact: [
            "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}",
          ],
          downloadJobLogsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs",
          ],
          downloadWorkflowRunAttemptLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs",
          ],
          downloadWorkflowRunLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs",
          ],
          enableSelectedRepositoryGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}",
          ],
          enableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable",
          ],
          forceCancelWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel",
          ],
          generateRunnerJitconfigForOrg: [
            "POST /orgs/{org}/actions/runners/generate-jitconfig",
          ],
          generateRunnerJitconfigForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig",
          ],
          getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
          getActionsCacheUsage: [
            "GET /repos/{owner}/{repo}/actions/cache/usage",
          ],
          getActionsCacheUsageByRepoForOrg: [
            "GET /orgs/{org}/actions/cache/usage-by-repository",
          ],
          getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
          getAllowedActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/selected-actions",
          ],
          getAllowedActionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/selected-actions",
          ],
          getArtifact: [
            "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}",
          ],
          getCustomOidcSubClaimForRepo: [
            "GET /repos/{owner}/{repo}/actions/oidc/customization/sub",
          ],
          getEnvironmentPublicKey: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key",
          ],
          getEnvironmentSecret: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}",
          ],
          getEnvironmentVariable: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}",
          ],
          getGithubActionsDefaultWorkflowPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions/workflow",
          ],
          getGithubActionsDefaultWorkflowPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/workflow",
          ],
          getGithubActionsPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions",
          ],
          getGithubActionsPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions",
          ],
          getHostedRunnerForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}",
          ],
          getHostedRunnersGithubOwnedImagesForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/images/github-owned",
          ],
          getHostedRunnersLimitsForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/limits",
          ],
          getHostedRunnersMachineSpecsForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/machine-sizes",
          ],
          getHostedRunnersPartnerImagesForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/images/partner",
          ],
          getHostedRunnersPlatformsForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/platforms",
          ],
          getJobForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/jobs/{job_id}",
          ],
          getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
          getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
          getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
          getPendingDeploymentsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
          ],
          getRepoPermissions: [
            "GET /repos/{owner}/{repo}/actions/permissions",
            {},
            { renamed: ["actions", "getGithubActionsPermissionsRepository"] },
          ],
          getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/actions/secrets/public-key",
          ],
          getRepoSecret: [
            "GET /repos/{owner}/{repo}/actions/secrets/{secret_name}",
          ],
          getRepoVariable: [
            "GET /repos/{owner}/{repo}/actions/variables/{name}",
          ],
          getReviewsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals",
          ],
          getSelfHostedRunnerForOrg: [
            "GET /orgs/{org}/actions/runners/{runner_id}",
          ],
          getSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}",
          ],
          getWorkflow: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}",
          ],
          getWorkflowAccessToRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/access",
          ],
          getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
          getWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}",
          ],
          getWorkflowRunUsage: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing",
          ],
          getWorkflowUsage: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing",
          ],
          listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
          listEnvironmentSecrets: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets",
          ],
          listEnvironmentVariables: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/variables",
          ],
          listGithubHostedRunnersInGroupForOrg: [
            "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners",
          ],
          listHostedRunnersForOrg: ["GET /orgs/{org}/actions/hosted-runners"],
          listJobsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
          ],
          listJobsForWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
          ],
          listLabelsForSelfHostedRunnerForOrg: [
            "GET /orgs/{org}/actions/runners/{runner_id}/labels",
          ],
          listLabelsForSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
          ],
          listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
          listOrgVariables: ["GET /orgs/{org}/actions/variables"],
          listRepoOrganizationSecrets: [
            "GET /repos/{owner}/{repo}/actions/organization-secrets",
          ],
          listRepoOrganizationVariables: [
            "GET /repos/{owner}/{repo}/actions/organization-variables",
          ],
          listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
          listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
          listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
          listRunnerApplicationsForOrg: [
            "GET /orgs/{org}/actions/runners/downloads",
          ],
          listRunnerApplicationsForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/downloads",
          ],
          listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
          ],
          listSelectedReposForOrgVariable: [
            "GET /orgs/{org}/actions/variables/{name}/repositories",
          ],
          listSelectedRepositoriesEnabledGithubActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/repositories",
          ],
          listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
          listSelfHostedRunnersForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners",
          ],
          listWorkflowRunArtifacts: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
          ],
          listWorkflowRuns: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
          ],
          listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
          reRunJobForWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun",
          ],
          reRunWorkflow: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun",
          ],
          reRunWorkflowFailedJobs: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs",
          ],
          removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels",
          ],
          removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
          ],
          removeCustomLabelFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}",
          ],
          removeCustomLabelFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}",
          ],
          removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}",
          ],
          removeSelectedRepoFromOrgVariable: [
            "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}",
          ],
          reviewCustomGatesForRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule",
          ],
          reviewPendingDeploymentsForRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments",
          ],
          setAllowedActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/selected-actions",
          ],
          setAllowedActionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions",
          ],
          setCustomLabelsForSelfHostedRunnerForOrg: [
            "PUT /orgs/{org}/actions/runners/{runner_id}/labels",
          ],
          setCustomLabelsForSelfHostedRunnerForRepo: [
            "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels",
          ],
          setCustomOidcSubClaimForRepo: [
            "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub",
          ],
          setGithubActionsDefaultWorkflowPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/workflow",
          ],
          setGithubActionsDefaultWorkflowPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/workflow",
          ],
          setGithubActionsPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions",
          ],
          setGithubActionsPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions",
          ],
          setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories",
          ],
          setSelectedReposForOrgVariable: [
            "PUT /orgs/{org}/actions/variables/{name}/repositories",
          ],
          setSelectedRepositoriesEnabledGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories",
          ],
          setWorkflowAccessToRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/access",
          ],
          updateEnvironmentVariable: [
            "PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}",
          ],
          updateHostedRunnerForOrg: [
            "PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}",
          ],
          updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
          updateRepoVariable: [
            "PATCH /repos/{owner}/{repo}/actions/variables/{name}",
          ],
        },
        activity: {
          checkRepoIsStarredByAuthenticatedUser: [
            "GET /user/starred/{owner}/{repo}",
          ],
          deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
          deleteThreadSubscription: [
            "DELETE /notifications/threads/{thread_id}/subscription",
          ],
          getFeeds: ["GET /feeds"],
          getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
          getThread: ["GET /notifications/threads/{thread_id}"],
          getThreadSubscriptionForAuthenticatedUser: [
            "GET /notifications/threads/{thread_id}/subscription",
          ],
          listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
          listNotificationsForAuthenticatedUser: ["GET /notifications"],
          listOrgEventsForAuthenticatedUser: [
            "GET /users/{username}/events/orgs/{org}",
          ],
          listPublicEvents: ["GET /events"],
          listPublicEventsForRepoNetwork: [
            "GET /networks/{owner}/{repo}/events",
          ],
          listPublicEventsForUser: ["GET /users/{username}/events/public"],
          listPublicOrgEvents: ["GET /orgs/{org}/events"],
          listReceivedEventsForUser: ["GET /users/{username}/received_events"],
          listReceivedPublicEventsForUser: [
            "GET /users/{username}/received_events/public",
          ],
          listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
          listRepoNotificationsForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/notifications",
          ],
          listReposStarredByAuthenticatedUser: ["GET /user/starred"],
          listReposStarredByUser: ["GET /users/{username}/starred"],
          listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
          listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
          listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
          listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
          markNotificationsAsRead: ["PUT /notifications"],
          markRepoNotificationsAsRead: [
            "PUT /repos/{owner}/{repo}/notifications",
          ],
          markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
          markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
          setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
          setThreadSubscription: [
            "PUT /notifications/threads/{thread_id}/subscription",
          ],
          starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
          unstarRepoForAuthenticatedUser: [
            "DELETE /user/starred/{owner}/{repo}",
          ],
        },
        apps: {
          addRepoToInstallation: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] },
          ],
          addRepoToInstallationForAuthenticatedUser: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}",
          ],
          checkToken: ["POST /applications/{client_id}/token"],
          createFromManifest: ["POST /app-manifests/{code}/conversions"],
          createInstallationAccessToken: [
            "POST /app/installations/{installation_id}/access_tokens",
          ],
          deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
          deleteInstallation: ["DELETE /app/installations/{installation_id}"],
          deleteToken: ["DELETE /applications/{client_id}/token"],
          getAuthenticated: ["GET /app"],
          getBySlug: ["GET /apps/{app_slug}"],
          getInstallation: ["GET /app/installations/{installation_id}"],
          getOrgInstallation: ["GET /orgs/{org}/installation"],
          getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
          getSubscriptionPlanForAccount: [
            "GET /marketplace_listing/accounts/{account_id}",
          ],
          getSubscriptionPlanForAccountStubbed: [
            "GET /marketplace_listing/stubbed/accounts/{account_id}",
          ],
          getUserInstallation: ["GET /users/{username}/installation"],
          getWebhookConfigForApp: ["GET /app/hook/config"],
          getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
          listAccountsForPlan: [
            "GET /marketplace_listing/plans/{plan_id}/accounts",
          ],
          listAccountsForPlanStubbed: [
            "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
          ],
          listInstallationReposForAuthenticatedUser: [
            "GET /user/installations/{installation_id}/repositories",
          ],
          listInstallationRequestsForAuthenticatedApp: [
            "GET /app/installation-requests",
          ],
          listInstallations: ["GET /app/installations"],
          listInstallationsForAuthenticatedUser: ["GET /user/installations"],
          listPlans: ["GET /marketplace_listing/plans"],
          listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
          listReposAccessibleToInstallation: ["GET /installation/repositories"],
          listSubscriptionsForAuthenticatedUser: [
            "GET /user/marketplace_purchases",
          ],
          listSubscriptionsForAuthenticatedUserStubbed: [
            "GET /user/marketplace_purchases/stubbed",
          ],
          listWebhookDeliveries: ["GET /app/hook/deliveries"],
          redeliverWebhookDelivery: [
            "POST /app/hook/deliveries/{delivery_id}/attempts",
          ],
          removeRepoFromInstallation: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            {
              renamed: [
                "apps",
                "removeRepoFromInstallationForAuthenticatedUser",
              ],
            },
          ],
          removeRepoFromInstallationForAuthenticatedUser: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
          ],
          resetToken: ["PATCH /applications/{client_id}/token"],
          revokeInstallationAccessToken: ["DELETE /installation/token"],
          scopeToken: ["POST /applications/{client_id}/token/scoped"],
          suspendInstallation: [
            "PUT /app/installations/{installation_id}/suspended",
          ],
          unsuspendInstallation: [
            "DELETE /app/installations/{installation_id}/suspended",
          ],
          updateWebhookConfigForApp: ["PATCH /app/hook/config"],
        },
        billing: {
          getGithubActionsBillingOrg: [
            "GET /orgs/{org}/settings/billing/actions",
          ],
          getGithubActionsBillingUser: [
            "GET /users/{username}/settings/billing/actions",
          ],
          getGithubBillingUsageReportOrg: [
            "GET /organizations/{org}/settings/billing/usage",
          ],
          getGithubBillingUsageReportUser: [
            "GET /users/{username}/settings/billing/usage",
          ],
          getGithubPackagesBillingOrg: [
            "GET /orgs/{org}/settings/billing/packages",
          ],
          getGithubPackagesBillingUser: [
            "GET /users/{username}/settings/billing/packages",
          ],
          getSharedStorageBillingOrg: [
            "GET /orgs/{org}/settings/billing/shared-storage",
          ],
          getSharedStorageBillingUser: [
            "GET /users/{username}/settings/billing/shared-storage",
          ],
        },
        campaigns: {
          createCampaign: ["POST /orgs/{org}/campaigns"],
          deleteCampaign: ["DELETE /orgs/{org}/campaigns/{campaign_number}"],
          getCampaignSummary: ["GET /orgs/{org}/campaigns/{campaign_number}"],
          listOrgCampaigns: ["GET /orgs/{org}/campaigns"],
          updateCampaign: ["PATCH /orgs/{org}/campaigns/{campaign_number}"],
        },
        checks: {
          create: ["POST /repos/{owner}/{repo}/check-runs"],
          createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
          get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
          getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
          listAnnotations: [
            "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
          ],
          listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
          listForSuite: [
            "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
          ],
          listSuitesForRef: [
            "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
          ],
          rerequestRun: [
            "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest",
          ],
          rerequestSuite: [
            "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest",
          ],
          setSuitesPreferences: [
            "PATCH /repos/{owner}/{repo}/check-suites/preferences",
          ],
          update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"],
        },
        codeScanning: {
          commitAutofix: [
            "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits",
          ],
          createAutofix: [
            "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix",
          ],
          createVariantAnalysis: [
            "POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses",
          ],
          deleteAnalysis: [
            "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}",
          ],
          deleteCodeqlDatabase: [
            "DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}",
          ],
          getAlert: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
            {},
            { renamedParameters: { alert_id: "alert_number" } },
          ],
          getAnalysis: [
            "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}",
          ],
          getAutofix: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix",
          ],
          getCodeqlDatabase: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}",
          ],
          getDefaultSetup: [
            "GET /repos/{owner}/{repo}/code-scanning/default-setup",
          ],
          getSarif: [
            "GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}",
          ],
          getVariantAnalysis: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}",
          ],
          getVariantAnalysisRepoTask: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}",
          ],
          listAlertInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
          ],
          listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
          listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
          listAlertsInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
            {},
            { renamed: ["codeScanning", "listAlertInstances"] },
          ],
          listCodeqlDatabases: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/databases",
          ],
          listRecentAnalyses: [
            "GET /repos/{owner}/{repo}/code-scanning/analyses",
          ],
          updateAlert: [
            "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
          ],
          updateDefaultSetup: [
            "PATCH /repos/{owner}/{repo}/code-scanning/default-setup",
          ],
          uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"],
        },
        codeSecurity: {
          attachConfiguration: [
            "POST /orgs/{org}/code-security/configurations/{configuration_id}/attach",
          ],
          attachEnterpriseConfiguration: [
            "POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach",
          ],
          createConfiguration: [
            "POST /orgs/{org}/code-security/configurations",
          ],
          createConfigurationForEnterprise: [
            "POST /enterprises/{enterprise}/code-security/configurations",
          ],
          deleteConfiguration: [
            "DELETE /orgs/{org}/code-security/configurations/{configuration_id}",
          ],
          deleteConfigurationForEnterprise: [
            "DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}",
          ],
          detachConfiguration: [
            "DELETE /orgs/{org}/code-security/configurations/detach",
          ],
          getConfiguration: [
            "GET /orgs/{org}/code-security/configurations/{configuration_id}",
          ],
          getConfigurationForRepository: [
            "GET /repos/{owner}/{repo}/code-security-configuration",
          ],
          getConfigurationsForEnterprise: [
            "GET /enterprises/{enterprise}/code-security/configurations",
          ],
          getConfigurationsForOrg: [
            "GET /orgs/{org}/code-security/configurations",
          ],
          getDefaultConfigurations: [
            "GET /orgs/{org}/code-security/configurations/defaults",
          ],
          getDefaultConfigurationsForEnterprise: [
            "GET /enterprises/{enterprise}/code-security/configurations/defaults",
          ],
          getRepositoriesForConfiguration: [
            "GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories",
          ],
          getRepositoriesForEnterpriseConfiguration: [
            "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories",
          ],
          getSingleConfigurationForEnterprise: [
            "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}",
          ],
          setConfigurationAsDefault: [
            "PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults",
          ],
          setConfigurationAsDefaultForEnterprise: [
            "PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults",
          ],
          updateConfiguration: [
            "PATCH /orgs/{org}/code-security/configurations/{configuration_id}",
          ],
          updateEnterpriseConfiguration: [
            "PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}",
          ],
        },
        codesOfConduct: {
          getAllCodesOfConduct: ["GET /codes_of_conduct"],
          getConductCode: ["GET /codes_of_conduct/{key}"],
        },
        codespaces: {
          addRepositoryForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}",
          ],
          addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}",
          ],
          checkPermissionsForDevcontainer: [
            "GET /repos/{owner}/{repo}/codespaces/permissions_check",
          ],
          codespaceMachinesForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/machines",
          ],
          createForAuthenticatedUser: ["POST /user/codespaces"],
          createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}",
          ],
          createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
          ],
          createOrUpdateSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}",
          ],
          createWithPrForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces",
          ],
          createWithRepoForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/codespaces",
          ],
          deleteForAuthenticatedUser: [
            "DELETE /user/codespaces/{codespace_name}",
          ],
          deleteFromOrganization: [
            "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}",
          ],
          deleteOrgSecret: [
            "DELETE /orgs/{org}/codespaces/secrets/{secret_name}",
          ],
          deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
          ],
          deleteSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}",
          ],
          exportForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/exports",
          ],
          getCodespacesForUserInOrg: [
            "GET /orgs/{org}/members/{username}/codespaces",
          ],
          getExportDetailsForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/exports/{export_id}",
          ],
          getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
          getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
          getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
          getPublicKeyForAuthenticatedUser: [
            "GET /user/codespaces/secrets/public-key",
          ],
          getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/public-key",
          ],
          getRepoSecret: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}",
          ],
          getSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}",
          ],
          listDevcontainersInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/devcontainers",
          ],
          listForAuthenticatedUser: ["GET /user/codespaces"],
          listInOrganization: [
            "GET /orgs/{org}/codespaces",
            {},
            { renamedParameters: { org_id: "org" } },
          ],
          listInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces",
          ],
          listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
          listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
          listRepositoriesForSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}/repositories",
          ],
          listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
          listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
          ],
          preFlightWithRepoForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/new",
          ],
          publishForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/publish",
          ],
          removeRepositoryForSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}",
          ],
          removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}",
          ],
          repoMachinesForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/machines",
          ],
          setRepositoriesForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories",
          ],
          setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
          ],
          startForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/start",
          ],
          stopForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/stop",
          ],
          stopInOrganization: [
            "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop",
          ],
          updateForAuthenticatedUser: [
            "PATCH /user/codespaces/{codespace_name}",
          ],
        },
        copilot: {
          addCopilotSeatsForTeams: [
            "POST /orgs/{org}/copilot/billing/selected_teams",
          ],
          addCopilotSeatsForUsers: [
            "POST /orgs/{org}/copilot/billing/selected_users",
          ],
          cancelCopilotSeatAssignmentForTeams: [
            "DELETE /orgs/{org}/copilot/billing/selected_teams",
          ],
          cancelCopilotSeatAssignmentForUsers: [
            "DELETE /orgs/{org}/copilot/billing/selected_users",
          ],
          copilotMetricsForOrganization: ["GET /orgs/{org}/copilot/metrics"],
          copilotMetricsForTeam: [
            "GET /orgs/{org}/team/{team_slug}/copilot/metrics",
          ],
          getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
          getCopilotSeatDetailsForUser: [
            "GET /orgs/{org}/members/{username}/copilot",
          ],
          listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"],
        },
        credentials: { revoke: ["POST /credentials/revoke"] },
        dependabot: {
          addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}",
          ],
          createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}",
          ],
          createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
          ],
          deleteOrgSecret: [
            "DELETE /orgs/{org}/dependabot/secrets/{secret_name}",
          ],
          deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
          ],
          getAlert: [
            "GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}",
          ],
          getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
          getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
          getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/public-key",
          ],
          getRepoSecret: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}",
          ],
          listAlertsForEnterprise: [
            "GET /enterprises/{enterprise}/dependabot/alerts",
          ],
          listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
          listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
          listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
          listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
          listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
          ],
          removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}",
          ],
          repositoryAccessForOrg: [
            "GET /organizations/{org}/dependabot/repository-access",
          ],
          setRepositoryAccessDefaultLevel: [
            "PUT /organizations/{org}/dependabot/repository-access/default-level",
          ],
          setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
          ],
          updateAlert: [
            "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}",
          ],
          updateRepositoryAccessForOrg: [
            "PATCH /organizations/{org}/dependabot/repository-access",
          ],
        },
        dependencyGraph: {
          createRepositorySnapshot: [
            "POST /repos/{owner}/{repo}/dependency-graph/snapshots",
          ],
          diffRange: [
            "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}",
          ],
          exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"],
        },
        emojis: { get: ["GET /emojis"] },
        gists: {
          checkIsStarred: ["GET /gists/{gist_id}/star"],
          create: ["POST /gists"],
          createComment: ["POST /gists/{gist_id}/comments"],
          delete: ["DELETE /gists/{gist_id}"],
          deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
          fork: ["POST /gists/{gist_id}/forks"],
          get: ["GET /gists/{gist_id}"],
          getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
          getRevision: ["GET /gists/{gist_id}/{sha}"],
          list: ["GET /gists"],
          listComments: ["GET /gists/{gist_id}/comments"],
          listCommits: ["GET /gists/{gist_id}/commits"],
          listForUser: ["GET /users/{username}/gists"],
          listForks: ["GET /gists/{gist_id}/forks"],
          listPublic: ["GET /gists/public"],
          listStarred: ["GET /gists/starred"],
          star: ["PUT /gists/{gist_id}/star"],
          unstar: ["DELETE /gists/{gist_id}/star"],
          update: ["PATCH /gists/{gist_id}"],
          updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"],
        },
        git: {
          createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
          createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
          createRef: ["POST /repos/{owner}/{repo}/git/refs"],
          createTag: ["POST /repos/{owner}/{repo}/git/tags"],
          createTree: ["POST /repos/{owner}/{repo}/git/trees"],
          deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
          getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
          getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
          getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
          getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
          getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
          listMatchingRefs: [
            "GET /repos/{owner}/{repo}/git/matching-refs/{ref}",
          ],
          updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"],
        },
        gitignore: {
          getAllTemplates: ["GET /gitignore/templates"],
          getTemplate: ["GET /gitignore/templates/{name}"],
        },
        hostedCompute: {
          createNetworkConfigurationForOrg: [
            "POST /orgs/{org}/settings/network-configurations",
          ],
          deleteNetworkConfigurationFromOrg: [
            "DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}",
          ],
          getNetworkConfigurationForOrg: [
            "GET /orgs/{org}/settings/network-configurations/{network_configuration_id}",
          ],
          getNetworkSettingsForOrg: [
            "GET /orgs/{org}/settings/network-settings/{network_settings_id}",
          ],
          listNetworkConfigurationsForOrg: [
            "GET /orgs/{org}/settings/network-configurations",
          ],
          updateNetworkConfigurationForOrg: [
            "PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}",
          ],
        },
        interactions: {
          getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
          getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
          getRestrictionsForRepo: [
            "GET /repos/{owner}/{repo}/interaction-limits",
          ],
          getRestrictionsForYourPublicRepos: [
            "GET /user/interaction-limits",
            {},
            {
              renamed: ["interactions", "getRestrictionsForAuthenticatedUser"],
            },
          ],
          removeRestrictionsForAuthenticatedUser: [
            "DELETE /user/interaction-limits",
          ],
          removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
          removeRestrictionsForRepo: [
            "DELETE /repos/{owner}/{repo}/interaction-limits",
          ],
          removeRestrictionsForYourPublicRepos: [
            "DELETE /user/interaction-limits",
            {},
            {
              renamed: [
                "interactions",
                "removeRestrictionsForAuthenticatedUser",
              ],
            },
          ],
          setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
          setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
          setRestrictionsForRepo: [
            "PUT /repos/{owner}/{repo}/interaction-limits",
          ],
          setRestrictionsForYourPublicRepos: [
            "PUT /user/interaction-limits",
            {},
            {
              renamed: ["interactions", "setRestrictionsForAuthenticatedUser"],
            },
          ],
        },
        issues: {
          addAssignees: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees",
          ],
          addBlockedByDependency: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by",
          ],
          addLabels: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/labels",
          ],
          addSubIssue: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues",
          ],
          checkUserCanBeAssigned: [
            "GET /repos/{owner}/{repo}/assignees/{assignee}",
          ],
          checkUserCanBeAssignedToIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}",
          ],
          create: ["POST /repos/{owner}/{repo}/issues"],
          createComment: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/comments",
          ],
          createLabel: ["POST /repos/{owner}/{repo}/labels"],
          createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
          deleteComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}",
          ],
          deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
          deleteMilestone: [
            "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}",
          ],
          get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
          getComment: [
            "GET /repos/{owner}/{repo}/issues/comments/{comment_id}",
          ],
          getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
          getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
          getMilestone: [
            "GET /repos/{owner}/{repo}/milestones/{milestone_number}",
          ],
          getParent: ["GET /repos/{owner}/{repo}/issues/{issue_number}/parent"],
          list: ["GET /issues"],
          listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
          listComments: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
          ],
          listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
          listDependenciesBlockedBy: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by",
          ],
          listDependenciesBlocking: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocking",
          ],
          listEvents: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
          ],
          listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
          listEventsForTimeline: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
          ],
          listForAuthenticatedUser: ["GET /user/issues"],
          listForOrg: ["GET /orgs/{org}/issues"],
          listForRepo: ["GET /repos/{owner}/{repo}/issues"],
          listLabelsForMilestone: [
            "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
          ],
          listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
          listLabelsOnIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
          ],
          listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
          listSubIssues: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues",
          ],
          lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
          removeAllLabels: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels",
          ],
          removeAssignees: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees",
          ],
          removeDependencyBlockedBy: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/dependencies/blocked_by/{issue_id}",
          ],
          removeLabel: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}",
          ],
          removeSubIssue: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue",
          ],
          reprioritizeSubIssue: [
            "PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority",
          ],
          setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
          unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
          update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
          updateComment: [
            "PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}",
          ],
          updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
          updateMilestone: [
            "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}",
          ],
        },
        licenses: {
          get: ["GET /licenses/{license}"],
          getAllCommonlyUsed: ["GET /licenses"],
          getForRepo: ["GET /repos/{owner}/{repo}/license"],
        },
        markdown: {
          render: ["POST /markdown"],
          renderRaw: [
            "POST /markdown/raw",
            { headers: { "content-type": "text/plain; charset=utf-8" } },
          ],
        },
        meta: {
          get: ["GET /meta"],
          getAllVersions: ["GET /versions"],
          getOctocat: ["GET /octocat"],
          getZen: ["GET /zen"],
          root: ["GET /"],
        },
        migrations: {
          deleteArchiveForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/archive",
          ],
          deleteArchiveForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/archive",
          ],
          downloadArchiveForOrg: [
            "GET /orgs/{org}/migrations/{migration_id}/archive",
          ],
          getArchiveForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/archive",
          ],
          getStatusForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}",
          ],
          getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
          listForAuthenticatedUser: ["GET /user/migrations"],
          listForOrg: ["GET /orgs/{org}/migrations"],
          listReposForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/repositories",
          ],
          listReposForOrg: [
            "GET /orgs/{org}/migrations/{migration_id}/repositories",
          ],
          listReposForUser: [
            "GET /user/migrations/{migration_id}/repositories",
            {},
            { renamed: ["migrations", "listReposForAuthenticatedUser"] },
          ],
          startForAuthenticatedUser: ["POST /user/migrations"],
          startForOrg: ["POST /orgs/{org}/migrations"],
          unlockRepoForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock",
          ],
          unlockRepoForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock",
          ],
        },
        oidc: {
          getOidcCustomSubTemplateForOrg: [
            "GET /orgs/{org}/actions/oidc/customization/sub",
          ],
          updateOidcCustomSubTemplateForOrg: [
            "PUT /orgs/{org}/actions/oidc/customization/sub",
          ],
        },
        orgs: {
          addSecurityManagerTeam: [
            "PUT /orgs/{org}/security-managers/teams/{team_slug}",
            {},
            {
              deprecated:
                "octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team",
            },
          ],
          assignTeamToOrgRole: [
            "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}",
          ],
          assignUserToOrgRole: [
            "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}",
          ],
          blockUser: ["PUT /orgs/{org}/blocks/{username}"],
          cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
          checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
          checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
          checkPublicMembershipForUser: [
            "GET /orgs/{org}/public_members/{username}",
          ],
          convertMemberToOutsideCollaborator: [
            "PUT /orgs/{org}/outside_collaborators/{username}",
          ],
          createArtifactStorageRecord: [
            "POST /orgs/{org}/artifacts/metadata/storage-record",
          ],
          createInvitation: ["POST /orgs/{org}/invitations"],
          createIssueType: ["POST /orgs/{org}/issue-types"],
          createOrUpdateCustomProperties: [
            "PATCH /orgs/{org}/properties/schema",
          ],
          createOrUpdateCustomPropertiesValuesForRepos: [
            "PATCH /orgs/{org}/properties/values",
          ],
          createOrUpdateCustomProperty: [
            "PUT /orgs/{org}/properties/schema/{custom_property_name}",
          ],
          createWebhook: ["POST /orgs/{org}/hooks"],
          delete: ["DELETE /orgs/{org}"],
          deleteAttestationsBulk: [
            "POST /orgs/{org}/attestations/delete-request",
          ],
          deleteAttestationsById: [
            "DELETE /orgs/{org}/attestations/{attestation_id}",
          ],
          deleteAttestationsBySubjectDigest: [
            "DELETE /orgs/{org}/attestations/digest/{subject_digest}",
          ],
          deleteIssueType: ["DELETE /orgs/{org}/issue-types/{issue_type_id}"],
          deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
          get: ["GET /orgs/{org}"],
          getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
          getCustomProperty: [
            "GET /orgs/{org}/properties/schema/{custom_property_name}",
          ],
          getMembershipForAuthenticatedUser: [
            "GET /user/memberships/orgs/{org}",
          ],
          getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
          getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
          getOrgRulesetHistory: [
            "GET /orgs/{org}/rulesets/{ruleset_id}/history",
          ],
          getOrgRulesetVersion: [
            "GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}",
          ],
          getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
          getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
          getWebhookDelivery: [
            "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}",
          ],
          list: ["GET /organizations"],
          listAppInstallations: ["GET /orgs/{org}/installations"],
          listArtifactStorageRecords: [
            "GET /orgs/{org}/artifacts/{subject_digest}/metadata/storage-records",
          ],
          listAttestations: ["GET /orgs/{org}/attestations/{subject_digest}"],
          listAttestationsBulk: [
            "POST /orgs/{org}/attestations/bulk-list{?per_page,before,after}",
          ],
          listBlockedUsers: ["GET /orgs/{org}/blocks"],
          listCustomPropertiesValuesForRepos: [
            "GET /orgs/{org}/properties/values",
          ],
          listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
          listForAuthenticatedUser: ["GET /user/orgs"],
          listForUser: ["GET /users/{username}/orgs"],
          listInvitationTeams: [
            "GET /orgs/{org}/invitations/{invitation_id}/teams",
          ],
          listIssueTypes: ["GET /orgs/{org}/issue-types"],
          listMembers: ["GET /orgs/{org}/members"],
          listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
          listOrgRoleTeams: [
            "GET /orgs/{org}/organization-roles/{role_id}/teams",
          ],
          listOrgRoleUsers: [
            "GET /orgs/{org}/organization-roles/{role_id}/users",
          ],
          listOrgRoles: ["GET /orgs/{org}/organization-roles"],
          listOrganizationFineGrainedPermissions: [
            "GET /orgs/{org}/organization-fine-grained-permissions",
          ],
          listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
          listPatGrantRepositories: [
            "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
          ],
          listPatGrantRequestRepositories: [
            "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
          ],
          listPatGrantRequests: [
            "GET /orgs/{org}/personal-access-token-requests",
          ],
          listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
          listPendingInvitations: ["GET /orgs/{org}/invitations"],
          listPublicMembers: ["GET /orgs/{org}/public_members"],
          listSecurityManagerTeams: [
            "GET /orgs/{org}/security-managers",
            {},
            {
              deprecated:
                "octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams",
            },
          ],
          listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
          listWebhooks: ["GET /orgs/{org}/hooks"],
          pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
          redeliverWebhookDelivery: [
            "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
          ],
          removeCustomProperty: [
            "DELETE /orgs/{org}/properties/schema/{custom_property_name}",
          ],
          removeMember: ["DELETE /orgs/{org}/members/{username}"],
          removeMembershipForUser: [
            "DELETE /orgs/{org}/memberships/{username}",
          ],
          removeOutsideCollaborator: [
            "DELETE /orgs/{org}/outside_collaborators/{username}",
          ],
          removePublicMembershipForAuthenticatedUser: [
            "DELETE /orgs/{org}/public_members/{username}",
          ],
          removeSecurityManagerTeam: [
            "DELETE /orgs/{org}/security-managers/teams/{team_slug}",
            {},
            {
              deprecated:
                "octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team",
            },
          ],
          reviewPatGrantRequest: [
            "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}",
          ],
          reviewPatGrantRequestsInBulk: [
            "POST /orgs/{org}/personal-access-token-requests",
          ],
          revokeAllOrgRolesTeam: [
            "DELETE /orgs/{org}/organization-roles/teams/{team_slug}",
          ],
          revokeAllOrgRolesUser: [
            "DELETE /orgs/{org}/organization-roles/users/{username}",
          ],
          revokeOrgRoleTeam: [
            "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}",
          ],
          revokeOrgRoleUser: [
            "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}",
          ],
          setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
          setPublicMembershipForAuthenticatedUser: [
            "PUT /orgs/{org}/public_members/{username}",
          ],
          unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
          update: ["PATCH /orgs/{org}"],
          updateIssueType: ["PUT /orgs/{org}/issue-types/{issue_type_id}"],
          updateMembershipForAuthenticatedUser: [
            "PATCH /user/memberships/orgs/{org}",
          ],
          updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
          updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
          updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
          updateWebhookConfigForOrg: [
            "PATCH /orgs/{org}/hooks/{hook_id}/config",
          ],
        },
        packages: {
          deletePackageForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}",
          ],
          deletePackageForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}",
          ],
          deletePackageForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}",
          ],
          deletePackageVersionForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
          ],
          deletePackageVersionForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
          ],
          deletePackageVersionForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
          ],
          getAllPackageVersionsForAPackageOwnedByAnOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
            {},
            {
              renamed: [
                "packages",
                "getAllPackageVersionsForPackageOwnedByOrg",
              ],
            },
          ],
          getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions",
            {},
            {
              renamed: [
                "packages",
                "getAllPackageVersionsForPackageOwnedByAuthenticatedUser",
              ],
            },
          ],
          getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions",
          ],
          getAllPackageVersionsForPackageOwnedByOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
          ],
          getAllPackageVersionsForPackageOwnedByUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions",
          ],
          getPackageForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}",
          ],
          getPackageForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}",
          ],
          getPackageForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}",
          ],
          getPackageVersionForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}",
          ],
          getPackageVersionForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}",
          ],
          getPackageVersionForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}",
          ],
          listDockerMigrationConflictingPackagesForAuthenticatedUser: [
            "GET /user/docker/conflicts",
          ],
          listDockerMigrationConflictingPackagesForOrganization: [
            "GET /orgs/{org}/docker/conflicts",
          ],
          listDockerMigrationConflictingPackagesForUser: [
            "GET /users/{username}/docker/conflicts",
          ],
          listPackagesForAuthenticatedUser: ["GET /user/packages"],
          listPackagesForOrganization: ["GET /orgs/{org}/packages"],
          listPackagesForUser: ["GET /users/{username}/packages"],
          restorePackageForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/restore{?token}",
          ],
          restorePackageForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}",
          ],
          restorePackageForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}",
          ],
          restorePackageVersionForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
          ],
          restorePackageVersionForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
          ],
          restorePackageVersionForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore",
          ],
        },
        privateRegistries: {
          createOrgPrivateRegistry: ["POST /orgs/{org}/private-registries"],
          deleteOrgPrivateRegistry: [
            "DELETE /orgs/{org}/private-registries/{secret_name}",
          ],
          getOrgPrivateRegistry: [
            "GET /orgs/{org}/private-registries/{secret_name}",
          ],
          getOrgPublicKey: ["GET /orgs/{org}/private-registries/public-key"],
          listOrgPrivateRegistries: ["GET /orgs/{org}/private-registries"],
          updateOrgPrivateRegistry: [
            "PATCH /orgs/{org}/private-registries/{secret_name}",
          ],
        },
        projects: {
          addItemForOrg: ["POST /orgs/{org}/projectsV2/{project_number}/items"],
          addItemForUser: [
            "POST /users/{user_id}/projectsV2/{project_number}/items",
          ],
          deleteItemForOrg: [
            "DELETE /orgs/{org}/projectsV2/{project_number}/items/{item_id}",
          ],
          deleteItemForUser: [
            "DELETE /users/{user_id}/projectsV2/{project_number}/items/{item_id}",
          ],
          getFieldForOrg: [
            "GET /orgs/{org}/projectsV2/{project_number}/fields/{field_id}",
          ],
          getFieldForUser: [
            "GET /users/{user_id}/projectsV2/{project_number}/fields/{field_id}",
          ],
          getForOrg: ["GET /orgs/{org}/projectsV2/{project_number}"],
          getForUser: ["GET /users/{user_id}/projectsV2/{project_number}"],
          getOrgItem: [
            "GET /orgs/{org}/projectsV2/{project_number}/items/{item_id}",
          ],
          getUserItem: [
            "GET /users/{user_id}/projectsV2/{project_number}/items/{item_id}",
          ],
          listFieldsForOrg: [
            "GET /orgs/{org}/projectsV2/{project_number}/fields",
          ],
          listFieldsForUser: [
            "GET /users/{user_id}/projectsV2/{project_number}/fields",
          ],
          listForOrg: ["GET /orgs/{org}/projectsV2"],
          listForUser: ["GET /users/{username}/projectsV2"],
          listItemsForOrg: [
            "GET /orgs/{org}/projectsV2/{project_number}/items",
          ],
          listItemsForUser: [
            "GET /users/{user_id}/projectsV2/{project_number}/items",
          ],
          updateItemForOrg: [
            "PATCH /orgs/{org}/projectsV2/{project_number}/items/{item_id}",
          ],
          updateItemForUser: [
            "PATCH /users/{user_id}/projectsV2/{project_number}/items/{item_id}",
          ],
        },
        pulls: {
          checkIfMerged: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/merge",
          ],
          create: ["POST /repos/{owner}/{repo}/pulls"],
          createReplyForReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies",
          ],
          createReview: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
          ],
          createReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments",
          ],
          deletePendingReview: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
          ],
          deleteReviewComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}",
          ],
          dismissReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals",
          ],
          get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
          getReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
          ],
          getReviewComment: [
            "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}",
          ],
          list: ["GET /repos/{owner}/{repo}/pulls"],
          listCommentsForReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
          ],
          listCommits: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
          ],
          listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
          listRequestedReviewers: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
          ],
          listReviewComments: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
          ],
          listReviewCommentsForRepo: [
            "GET /repos/{owner}/{repo}/pulls/comments",
          ],
          listReviews: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
          ],
          merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
          removeRequestedReviewers: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
          ],
          requestReviewers: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
          ],
          submitReview: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events",
          ],
          update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
          updateBranch: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch",
          ],
          updateReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}",
          ],
          updateReviewComment: [
            "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}",
          ],
        },
        rateLimit: { get: ["GET /rate_limit"] },
        reactions: {
          createForCommitComment: [
            "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions",
          ],
          createForIssue: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions",
          ],
          createForIssueComment: [
            "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
          ],
          createForPullRequestReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
          ],
          createForRelease: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/reactions",
          ],
          createForTeamDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
          ],
          createForTeamDiscussionInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
          ],
          deleteForCommitComment: [
            "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}",
          ],
          deleteForIssue: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}",
          ],
          deleteForIssueComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}",
          ],
          deleteForPullRequestComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}",
          ],
          deleteForRelease: [
            "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}",
          ],
          deleteForTeamDiscussion: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}",
          ],
          deleteForTeamDiscussionComment: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}",
          ],
          listForCommitComment: [
            "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
          ],
          listForIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
          ],
          listForIssueComment: [
            "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
          ],
          listForPullRequestReviewComment: [
            "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
          ],
          listForRelease: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
          ],
          listForTeamDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
          ],
          listForTeamDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
          ],
        },
        repos: {
          acceptInvitation: [
            "PATCH /user/repository_invitations/{invitation_id}",
            {},
            { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] },
          ],
          acceptInvitationForAuthenticatedUser: [
            "PATCH /user/repository_invitations/{invitation_id}",
          ],
          addAppAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
          ],
          addCollaborator: [
            "PUT /repos/{owner}/{repo}/collaborators/{username}",
          ],
          addStatusCheckContexts: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
          ],
          addTeamAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
          ],
          addUserAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
          ],
          cancelPagesDeployment: [
            "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel",
          ],
          checkAutomatedSecurityFixes: [
            "GET /repos/{owner}/{repo}/automated-security-fixes",
          ],
          checkCollaborator: [
            "GET /repos/{owner}/{repo}/collaborators/{username}",
          ],
          checkPrivateVulnerabilityReporting: [
            "GET /repos/{owner}/{repo}/private-vulnerability-reporting",
          ],
          checkVulnerabilityAlerts: [
            "GET /repos/{owner}/{repo}/vulnerability-alerts",
          ],
          codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
          compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
          compareCommitsWithBasehead: [
            "GET /repos/{owner}/{repo}/compare/{basehead}",
          ],
          createAttestation: ["POST /repos/{owner}/{repo}/attestations"],
          createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
          createCommitComment: [
            "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments",
          ],
          createCommitSignatureProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
          ],
          createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
          createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
          createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
          createDeploymentBranchPolicy: [
            "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
          ],
          createDeploymentProtectionRule: [
            "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules",
          ],
          createDeploymentStatus: [
            "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
          ],
          createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
          createForAuthenticatedUser: ["POST /user/repos"],
          createFork: ["POST /repos/{owner}/{repo}/forks"],
          createInOrg: ["POST /orgs/{org}/repos"],
          createOrUpdateCustomPropertiesValues: [
            "PATCH /repos/{owner}/{repo}/properties/values",
          ],
          createOrUpdateEnvironment: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}",
          ],
          createOrUpdateFileContents: [
            "PUT /repos/{owner}/{repo}/contents/{path}",
          ],
          createOrgRuleset: ["POST /orgs/{org}/rulesets"],
          createPagesDeployment: [
            "POST /repos/{owner}/{repo}/pages/deployments",
          ],
          createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
          createRelease: ["POST /repos/{owner}/{repo}/releases"],
          createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
          createUsingTemplate: [
            "POST /repos/{template_owner}/{template_repo}/generate",
          ],
          createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
          declineInvitation: [
            "DELETE /user/repository_invitations/{invitation_id}",
            {},
            { renamed: ["repos", "declineInvitationForAuthenticatedUser"] },
          ],
          declineInvitationForAuthenticatedUser: [
            "DELETE /user/repository_invitations/{invitation_id}",
          ],
          delete: ["DELETE /repos/{owner}/{repo}"],
          deleteAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
          ],
          deleteAdminBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
          ],
          deleteAnEnvironment: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}",
          ],
          deleteAutolink: [
            "DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}",
          ],
          deleteBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection",
          ],
          deleteCommitComment: [
            "DELETE /repos/{owner}/{repo}/comments/{comment_id}",
          ],
          deleteCommitSignatureProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
          ],
          deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
          deleteDeployment: [
            "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}",
          ],
          deleteDeploymentBranchPolicy: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}",
          ],
          deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
          deleteInvitation: [
            "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}",
          ],
          deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
          deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
          deletePullRequestReviewProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
          ],
          deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
          deleteReleaseAsset: [
            "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}",
          ],
          deleteRepoRuleset: [
            "DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}",
          ],
          deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
          disableAutomatedSecurityFixes: [
            "DELETE /repos/{owner}/{repo}/automated-security-fixes",
          ],
          disableDeploymentProtectionRule: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}",
          ],
          disablePrivateVulnerabilityReporting: [
            "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting",
          ],
          disableVulnerabilityAlerts: [
            "DELETE /repos/{owner}/{repo}/vulnerability-alerts",
          ],
          downloadArchive: [
            "GET /repos/{owner}/{repo}/zipball/{ref}",
            {},
            { renamed: ["repos", "downloadZipballArchive"] },
          ],
          downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
          downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
          enableAutomatedSecurityFixes: [
            "PUT /repos/{owner}/{repo}/automated-security-fixes",
          ],
          enablePrivateVulnerabilityReporting: [
            "PUT /repos/{owner}/{repo}/private-vulnerability-reporting",
          ],
          enableVulnerabilityAlerts: [
            "PUT /repos/{owner}/{repo}/vulnerability-alerts",
          ],
          generateReleaseNotes: [
            "POST /repos/{owner}/{repo}/releases/generate-notes",
          ],
          get: ["GET /repos/{owner}/{repo}"],
          getAccessRestrictions: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions",
          ],
          getAdminBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
          ],
          getAllDeploymentProtectionRules: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules",
          ],
          getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
          getAllStatusCheckContexts: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          ],
          getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
          getAppsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          ],
          getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
          getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
          getBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection",
          ],
          getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
          getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
          getCodeFrequencyStats: [
            "GET /repos/{owner}/{repo}/stats/code_frequency",
          ],
          getCollaboratorPermissionLevel: [
            "GET /repos/{owner}/{repo}/collaborators/{username}/permission",
          ],
          getCombinedStatusForRef: [
            "GET /repos/{owner}/{repo}/commits/{ref}/status",
          ],
          getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
          getCommitActivityStats: [
            "GET /repos/{owner}/{repo}/stats/commit_activity",
          ],
          getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
          getCommitSignatureProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures",
          ],
          getCommunityProfileMetrics: [
            "GET /repos/{owner}/{repo}/community/profile",
          ],
          getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
          getContributorsStats: [
            "GET /repos/{owner}/{repo}/stats/contributors",
          ],
          getCustomDeploymentProtectionRule: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}",
          ],
          getCustomPropertiesValues: [
            "GET /repos/{owner}/{repo}/properties/values",
          ],
          getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
          getDeployment: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}",
          ],
          getDeploymentBranchPolicy: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}",
          ],
          getDeploymentStatus: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}",
          ],
          getEnvironment: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}",
          ],
          getLatestPagesBuild: [
            "GET /repos/{owner}/{repo}/pages/builds/latest",
          ],
          getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
          getOrgRuleSuite: [
            "GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}",
          ],
          getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
          getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
          getOrgRulesets: ["GET /orgs/{org}/rulesets"],
          getPages: ["GET /repos/{owner}/{repo}/pages"],
          getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
          getPagesDeployment: [
            "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}",
          ],
          getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
          getParticipationStats: [
            "GET /repos/{owner}/{repo}/stats/participation",
          ],
          getPullRequestReviewProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
          ],
          getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
          getReadme: ["GET /repos/{owner}/{repo}/readme"],
          getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
          getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
          getReleaseAsset: [
            "GET /repos/{owner}/{repo}/releases/assets/{asset_id}",
          ],
          getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
          getRepoRuleSuite: [
            "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}",
          ],
          getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
          getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
          getRepoRulesetHistory: [
            "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history",
          ],
          getRepoRulesetVersion: [
            "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}",
          ],
          getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
          getStatusChecksProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
          ],
          getTeamsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          ],
          getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
          getTopReferrers: [
            "GET /repos/{owner}/{repo}/traffic/popular/referrers",
          ],
          getUsersWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          ],
          getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
          getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
          getWebhookConfigForRepo: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/config",
          ],
          getWebhookDelivery: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}",
          ],
          listActivities: ["GET /repos/{owner}/{repo}/activity"],
          listAttestations: [
            "GET /repos/{owner}/{repo}/attestations/{subject_digest}",
          ],
          listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
          listBranches: ["GET /repos/{owner}/{repo}/branches"],
          listBranchesForHeadCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head",
          ],
          listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
          listCommentsForCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
          ],
          listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
          listCommitStatusesForRef: [
            "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
          ],
          listCommits: ["GET /repos/{owner}/{repo}/commits"],
          listContributors: ["GET /repos/{owner}/{repo}/contributors"],
          listCustomDeploymentRuleIntegrations: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
          ],
          listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
          listDeploymentBranchPolicies: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
          ],
          listDeploymentStatuses: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
          ],
          listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
          listForAuthenticatedUser: ["GET /user/repos"],
          listForOrg: ["GET /orgs/{org}/repos"],
          listForUser: ["GET /users/{username}/repos"],
          listForks: ["GET /repos/{owner}/{repo}/forks"],
          listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
          listInvitationsForAuthenticatedUser: [
            "GET /user/repository_invitations",
          ],
          listLanguages: ["GET /repos/{owner}/{repo}/languages"],
          listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
          listPublic: ["GET /repositories"],
          listPullRequestsAssociatedWithCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
          ],
          listReleaseAssets: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
          ],
          listReleases: ["GET /repos/{owner}/{repo}/releases"],
          listTags: ["GET /repos/{owner}/{repo}/tags"],
          listTeams: ["GET /repos/{owner}/{repo}/teams"],
          listWebhookDeliveries: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
          ],
          listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
          merge: ["POST /repos/{owner}/{repo}/merges"],
          mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
          pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
          redeliverWebhookDelivery: [
            "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts",
          ],
          removeAppAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
          ],
          removeCollaborator: [
            "DELETE /repos/{owner}/{repo}/collaborators/{username}",
          ],
          removeStatusCheckContexts: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
          ],
          removeStatusCheckProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
          ],
          removeTeamAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
          ],
          removeUserAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
          ],
          renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
          replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
          requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
          setAdminBranchProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins",
          ],
          setAppAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            { mapToData: "apps" },
          ],
          setStatusCheckContexts: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            { mapToData: "contexts" },
          ],
          setTeamAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            { mapToData: "teams" },
          ],
          setUserAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            { mapToData: "users" },
          ],
          testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
          transfer: ["POST /repos/{owner}/{repo}/transfer"],
          update: ["PATCH /repos/{owner}/{repo}"],
          updateBranchProtection: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection",
          ],
          updateCommitComment: [
            "PATCH /repos/{owner}/{repo}/comments/{comment_id}",
          ],
          updateDeploymentBranchPolicy: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}",
          ],
          updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
          updateInvitation: [
            "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}",
          ],
          updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
          updatePullRequestReviewProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews",
          ],
          updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
          updateReleaseAsset: [
            "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}",
          ],
          updateRepoRuleset: [
            "PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}",
          ],
          updateStatusCheckPotection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
            {},
            { renamed: ["repos", "updateStatusCheckProtection"] },
          ],
          updateStatusCheckProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
          ],
          updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
          updateWebhookConfigForRepo: [
            "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config",
          ],
          uploadReleaseAsset: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
            { baseUrl: "https://uploads.github.com" },
          ],
        },
        search: {
          code: ["GET /search/code"],
          commits: ["GET /search/commits"],
          issuesAndPullRequests: [
            "GET /search/issues",
            {},
            {
              deprecated:
                "octokit.rest.search.issuesAndPullRequests() is deprecated, see https://docs.github.com/rest/search/search#search-issues-and-pull-requests",
            },
          ],
          labels: ["GET /search/labels"],
          repos: ["GET /search/repositories"],
          topics: ["GET /search/topics"],
          users: ["GET /search/users"],
        },
        secretScanning: {
          createPushProtectionBypass: [
            "POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses",
          ],
          getAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
          ],
          getScanHistory: [
            "GET /repos/{owner}/{repo}/secret-scanning/scan-history",
          ],
          listAlertsForEnterprise: [
            "GET /enterprises/{enterprise}/secret-scanning/alerts",
          ],
          listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
          listAlertsForRepo: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts",
          ],
          listLocationsForAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
          ],
          listOrgPatternConfigs: [
            "GET /orgs/{org}/secret-scanning/pattern-configurations",
          ],
          updateAlert: [
            "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}",
          ],
          updateOrgPatternConfigs: [
            "PATCH /orgs/{org}/secret-scanning/pattern-configurations",
          ],
        },
        securityAdvisories: {
          createFork: [
            "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks",
          ],
          createPrivateVulnerabilityReport: [
            "POST /repos/{owner}/{repo}/security-advisories/reports",
          ],
          createRepositoryAdvisory: [
            "POST /repos/{owner}/{repo}/security-advisories",
          ],
          createRepositoryAdvisoryCveRequest: [
            "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve",
          ],
          getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
          getRepositoryAdvisory: [
            "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}",
          ],
          listGlobalAdvisories: ["GET /advisories"],
          listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
          listRepositoryAdvisories: [
            "GET /repos/{owner}/{repo}/security-advisories",
          ],
          updateRepositoryAdvisory: [
            "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}",
          ],
        },
        teams: {
          addOrUpdateMembershipForUserInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}",
          ],
          addOrUpdateRepoPermissionsInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
          ],
          checkPermissionsForRepoInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
          ],
          create: ["POST /orgs/{org}/teams"],
          createDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
          ],
          createDiscussionInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions",
          ],
          deleteDiscussionCommentInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
          ],
          deleteDiscussionInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
          ],
          deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
          getByName: ["GET /orgs/{org}/teams/{team_slug}"],
          getDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
          ],
          getDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
          ],
          getMembershipForUserInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/memberships/{username}",
          ],
          list: ["GET /orgs/{org}/teams"],
          listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
          listDiscussionCommentsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
          ],
          listDiscussionsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions",
          ],
          listForAuthenticatedUser: ["GET /user/teams"],
          listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
          listPendingInvitationsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/invitations",
          ],
          listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
          removeMembershipForUserInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}",
          ],
          removeRepoInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}",
          ],
          updateDiscussionCommentInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}",
          ],
          updateDiscussionInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}",
          ],
          updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"],
        },
        users: {
          addEmailForAuthenticated: [
            "POST /user/emails",
            {},
            { renamed: ["users", "addEmailForAuthenticatedUser"] },
          ],
          addEmailForAuthenticatedUser: ["POST /user/emails"],
          addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
          block: ["PUT /user/blocks/{username}"],
          checkBlocked: ["GET /user/blocks/{username}"],
          checkFollowingForUser: [
            "GET /users/{username}/following/{target_user}",
          ],
          checkPersonIsFollowedByAuthenticated: [
            "GET /user/following/{username}",
          ],
          createGpgKeyForAuthenticated: [
            "POST /user/gpg_keys",
            {},
            { renamed: ["users", "createGpgKeyForAuthenticatedUser"] },
          ],
          createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
          createPublicSshKeyForAuthenticated: [
            "POST /user/keys",
            {},
            { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] },
          ],
          createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
          createSshSigningKeyForAuthenticatedUser: [
            "POST /user/ssh_signing_keys",
          ],
          deleteAttestationsBulk: [
            "POST /users/{username}/attestations/delete-request",
          ],
          deleteAttestationsById: [
            "DELETE /users/{username}/attestations/{attestation_id}",
          ],
          deleteAttestationsBySubjectDigest: [
            "DELETE /users/{username}/attestations/digest/{subject_digest}",
          ],
          deleteEmailForAuthenticated: [
            "DELETE /user/emails",
            {},
            { renamed: ["users", "deleteEmailForAuthenticatedUser"] },
          ],
          deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
          deleteGpgKeyForAuthenticated: [
            "DELETE /user/gpg_keys/{gpg_key_id}",
            {},
            { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] },
          ],
          deleteGpgKeyForAuthenticatedUser: [
            "DELETE /user/gpg_keys/{gpg_key_id}",
          ],
          deletePublicSshKeyForAuthenticated: [
            "DELETE /user/keys/{key_id}",
            {},
            { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] },
          ],
          deletePublicSshKeyForAuthenticatedUser: [
            "DELETE /user/keys/{key_id}",
          ],
          deleteSocialAccountForAuthenticatedUser: [
            "DELETE /user/social_accounts",
          ],
          deleteSshSigningKeyForAuthenticatedUser: [
            "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}",
          ],
          follow: ["PUT /user/following/{username}"],
          getAuthenticated: ["GET /user"],
          getById: ["GET /user/{account_id}"],
          getByUsername: ["GET /users/{username}"],
          getContextForUser: ["GET /users/{username}/hovercard"],
          getGpgKeyForAuthenticated: [
            "GET /user/gpg_keys/{gpg_key_id}",
            {},
            { renamed: ["users", "getGpgKeyForAuthenticatedUser"] },
          ],
          getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
          getPublicSshKeyForAuthenticated: [
            "GET /user/keys/{key_id}",
            {},
            { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] },
          ],
          getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
          getSshSigningKeyForAuthenticatedUser: [
            "GET /user/ssh_signing_keys/{ssh_signing_key_id}",
          ],
          list: ["GET /users"],
          listAttestations: [
            "GET /users/{username}/attestations/{subject_digest}",
          ],
          listAttestationsBulk: [
            "POST /users/{username}/attestations/bulk-list{?per_page,before,after}",
          ],
          listBlockedByAuthenticated: [
            "GET /user/blocks",
            {},
            { renamed: ["users", "listBlockedByAuthenticatedUser"] },
          ],
          listBlockedByAuthenticatedUser: ["GET /user/blocks"],
          listEmailsForAuthenticated: [
            "GET /user/emails",
            {},
            { renamed: ["users", "listEmailsForAuthenticatedUser"] },
          ],
          listEmailsForAuthenticatedUser: ["GET /user/emails"],
          listFollowedByAuthenticated: [
            "GET /user/following",
            {},
            { renamed: ["users", "listFollowedByAuthenticatedUser"] },
          ],
          listFollowedByAuthenticatedUser: ["GET /user/following"],
          listFollowersForAuthenticatedUser: ["GET /user/followers"],
          listFollowersForUser: ["GET /users/{username}/followers"],
          listFollowingForUser: ["GET /users/{username}/following"],
          listGpgKeysForAuthenticated: [
            "GET /user/gpg_keys",
            {},
            { renamed: ["users", "listGpgKeysForAuthenticatedUser"] },
          ],
          listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
          listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
          listPublicEmailsForAuthenticated: [
            "GET /user/public_emails",
            {},
            { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] },
          ],
          listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
          listPublicKeysForUser: ["GET /users/{username}/keys"],
          listPublicSshKeysForAuthenticated: [
            "GET /user/keys",
            {},
            { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] },
          ],
          listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
          listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
          listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
          listSshSigningKeysForAuthenticatedUser: [
            "GET /user/ssh_signing_keys",
          ],
          listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
          setPrimaryEmailVisibilityForAuthenticated: [
            "PATCH /user/email/visibility",
            {},
            {
              renamed: [
                "users",
                "setPrimaryEmailVisibilityForAuthenticatedUser",
              ],
            },
          ],
          setPrimaryEmailVisibilityForAuthenticatedUser: [
            "PATCH /user/email/visibility",
          ],
          unblock: ["DELETE /user/blocks/{username}"],
          unfollow: ["DELETE /user/following/{username}"],
          updateAuthenticated: ["PATCH /user"],
        },
      };
      var endpoints_default = Endpoints; // CONCATENATED MODULE: ./node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js

      //# sourceMappingURL=endpoints.js.map

      const endpointMethodsMap = /* @__PURE__ */ new Map();
      for (const [scope, endpoints] of Object.entries(endpoints_default)) {
        for (const [methodName, endpoint] of Object.entries(endpoints)) {
          const [route, defaults, decorations] = endpoint;
          const [method, url] = route.split(/ /);
          const endpointDefaults = Object.assign(
            {
              method,
              url,
            },
            defaults,
          );
          if (!endpointMethodsMap.has(scope)) {
            endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
          }
          endpointMethodsMap.get(scope).set(methodName, {
            scope,
            methodName,
            endpointDefaults,
            decorations,
          });
        }
      }
      const handler = {
        has({ scope }, methodName) {
          return endpointMethodsMap.get(scope).has(methodName);
        },
        getOwnPropertyDescriptor(target, methodName) {
          return {
            value: this.get(target, methodName),
            // ensures method is in the cache
            configurable: true,
            writable: true,
            enumerable: true,
          };
        },
        defineProperty(target, methodName, descriptor) {
          Object.defineProperty(target.cache, methodName, descriptor);
          return true;
        },
        deleteProperty(target, methodName) {
          delete target.cache[methodName];
          return true;
        },
        ownKeys({ scope }) {
          return [...endpointMethodsMap.get(scope).keys()];
        },
        set(target, methodName, value) {
          return (target.cache[methodName] = value);
        },
        get({ octokit, scope, cache }, methodName) {
          if (cache[methodName]) {
            return cache[methodName];
          }
          const method = endpointMethodsMap.get(scope).get(methodName);
          if (!method) {
            return void 0;
          }
          const { endpointDefaults, decorations } = method;
          if (decorations) {
            cache[methodName] = decorate(
              octokit,
              scope,
              methodName,
              endpointDefaults,
              decorations,
            );
          } else {
            cache[methodName] = octokit.request.defaults(endpointDefaults);
          }
          return cache[methodName];
        },
      };
      function endpointsToMethods(octokit) {
        const newMethods = {};
        for (const scope of endpointMethodsMap.keys()) {
          newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
        }
        return newMethods;
      }
      function decorate(octokit, scope, methodName, defaults, decorations) {
        const requestWithDefaults = octokit.request.defaults(defaults);
        function withDecorations(...args) {
          let options = requestWithDefaults.endpoint.merge(...args);
          if (decorations.mapToData) {
            options = Object.assign({}, options, {
              data: options[decorations.mapToData],
              [decorations.mapToData]: void 0,
            });
            return requestWithDefaults(options);
          }
          if (decorations.renamed) {
            const [newScope, newMethodName] = decorations.renamed;
            octokit.log.warn(
              `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`,
            );
          }
          if (decorations.deprecated) {
            octokit.log.warn(decorations.deprecated);
          }
          if (decorations.renamedParameters) {
            const options2 = requestWithDefaults.endpoint.merge(...args);
            for (const [name, alias] of Object.entries(
              decorations.renamedParameters,
            )) {
              if (name in options2) {
                octokit.log.warn(
                  `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`,
                );
                if (!(alias in options2)) {
                  options2[alias] = options2[name];
                }
                delete options2[name];
              }
            }
            return requestWithDefaults(options2);
          }
          return requestWithDefaults(...args);
        }
        return Object.assign(withDecorations, requestWithDefaults);
      } // CONCATENATED MODULE: ./node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js

      //# sourceMappingURL=endpoints-to-methods.js.map

      function restEndpointMethods(octokit) {
        const api = endpointsToMethods(octokit);
        return {
          rest: api,
        };
      }
      restEndpointMethods.VERSION =
        plugin_rest_endpoint_methods_dist_src_version_VERSION;
      function legacyRestEndpointMethods(octokit) {
        const api = endpointsToMethods(octokit);
        return {
          ...api,
          rest: api,
        };
      }
      legacyRestEndpointMethods.VERSION =
        plugin_rest_endpoint_methods_dist_src_version_VERSION; // CONCATENATED MODULE: ./node_modules/@octokit/rest/dist-src/version.js

      //# sourceMappingURL=index.js.map

      const rest_dist_src_version_VERSION = "22.0.0"; // CONCATENATED MODULE: ./node_modules/@octokit/rest/dist-src/index.js

      const dist_src_Octokit = Octokit.plugin(
        requestLog,
        legacyRestEndpointMethods,
        paginateRest,
      ).defaults({
        userAgent: `octokit-rest.js/${rest_dist_src_version_VERSION}`,
      });

      /***/
    },

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __nccwpck_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ // no module.id needed
      /******/ // no module.loaded needed
      /******/ exports: {},
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ var threw = true;
    /******/ try {
      /******/ __webpack_modules__[moduleId].call(
        module.exports,
        module,
        module.exports,
        __nccwpck_require__,
      );
      /******/ threw = false;
      /******/
    } finally {
      /******/ if (threw) delete __webpack_module_cache__[moduleId];
      /******/
    }
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/define property getters */
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __nccwpck_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (
          __nccwpck_require__.o(definition, key) &&
          !__nccwpck_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key],
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __nccwpck_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __nccwpck_require__.r = (exports) => {
      /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: "Module",
        });
        /******/
      }
      /******/ Object.defineProperty(exports, "__esModule", { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/compat */
  /******/
  /******/ if (typeof __nccwpck_require__ !== "undefined")
    __nccwpck_require__.ab = __dirname + "/";
  /******/
  /************************************************************************/
  /******/
  /******/ // startup
  /******/ // Load entry module and return exports
  /******/ // This entry module is referenced by other modules so it can't be inlined
  /******/ var __webpack_exports__ = __nccwpck_require__(407);
  /******/ module.exports = __webpack_exports__;
  /******/
  /******/
})();
//# sourceMappingURL=index.js.map
